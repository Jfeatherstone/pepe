<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>pepe.topology.Clustering API documentation</title>
<meta name="description" content="These methods aren&#39;t really &#39;topological&#39;, but I think this is
still the most apt place to put this code.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pepe.topology.Clustering</code></h1>
</header>
<section id="section-intro">
<p>These methods aren't really 'topological', but I think this is
still the most apt place to put this code.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pepe.topology.Clustering.spatialClusterCenters"><code class="name flex">
<span>def <span class="ident">spatialClusterCenters</span></span>(<span>points, l=0.001, randomize=False, wrapPoints=None, pointWeights=None, return_weights=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Partition a set of points in clusters, and compute the
center of each cluster.</p>
<p>Generates clusters using <code>pepe.topology.spatialClusterLabels()</code>; see
this method for more information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>numpy.ndarray[N,d]</code></dt>
<dd>Array of N points in d-dimensions</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance threshold to consider two points as being in the
same cluster. Given as fraction of the total system size.</dd>
<dt><strong><code>randomize</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>The clustering processes is dependent on the order of
the points; if <code>randomOrder=True</code>, the provided array will
be indexed in a random order, otherwise it will be accessed
exactly as provided. </p>
<p>See documentation for <code>pepe.topology.spatialClusterLabels()</code>.</p>
</dd>
<dt><strong><code>wrapPoints</code></strong> :&ensp;<code>numpy.ndarray[d]</code> or <code>float</code> or <code>None</code></dt>
<dd>
<p>If the space is periodic, the size of each dimension. If
a single value is given, this will be used for all dimensions.</p>
<p>If None, no periodicity is assumed.</p>
<p>Can have a mix of periodic and non-periodic dimensions,
eg. spherical coordinates should have:
<code>wrapPoints=[None, 2*np.pi, np.pi]</code></p>
</dd>
<dt><strong><code>pointWeights</code></strong> :&ensp;<code>numpy.ndarray[N]</code> or <code>None</code></dt>
<dd>An array of weights to be used in finding the center of
mass of each cluster. If <code>None</code>, every point will be
weighted the same.</dd>
<dt><strong><code>return_weights</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to return the weight &ndash; defined as the fraction of
points included in that cluster &ndash; alongside the centers.</p>
<p>If a weight is given for each point using <code>pointWeights</code>, this
will be used in calculating the weight of a cluster.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>centers</code></strong> :&ensp;<code>numpy.ndarray[N, d]</code></dt>
<dd>Array of N points in d-dimensions representing the detected
clusters in the system.</dd>
<dt><strong><code>weights</code></strong> :&ensp;<code>numpy.ndarray[N]</code></dt>
<dd>Array of weights &ndash; defined as fraction of all points included
in each cluster &ndash; for each cluster. Only returned if
<code>return_weights=True</code>.</dd>
</dl></div>
</dd>
<dt id="pepe.topology.Clustering.spatialClusterLabels"><code class="name flex">
<span>def <span class="ident">spatialClusterLabels</span></span>(<span>points, l=0.001, randomize=False, wrapPoints=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Partition a set of points in clusters, and return the
cluster label for each point.</p>
<p>Method is very simplistic: the neighbors (points within
a threshold distance) of a point are added to the same
cluster, and the process is repeated until no points
remain. This means that the size of clusters can be
larger than this distance threshold (eg. think of a
chain of points).</p>
<h2 id="usage">Usage</h2>
<p>The partitioning process is done by iterating through all
of the provided points, and identifying their neighbors. As
such, this process can vary based on the order the points are
provided in. There are two different ways to deal with this
while still maintaining reproducible results.</p>
<p>First, you can order the points in some meaningful way, with
the more important (whatever that means for your case) points
coming first. This should be done before calling this partitioning
method. Second, you can use the <code>randomize=True</code> kwarg, and rely
on the fact that this should lead to a statistically sound
calculation.</p>
<p>As an example, consider identifying clusters of points above some
threshold (whether in brightness, <span><span class="MathJax_Preview">G^2</span><script type="math/tex">G^2</script></span>, or whatever else) in
an image. For the first approach, you might order the points by the
magnitude of the parameter you are thresholding with respect to, since
eg. it could be assumed that very bright points are more important
than points that are just barely above the threshold. For the second
approach, you might perform the clustering process M times to get
a statistical ensemble, and then resolve the individual partitionings
into a single combined one.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>numpy.ndarray[N,d]</code></dt>
<dd>Array of N points in d-dimensions</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>Distance threshold to consider two points as being in the
same cluster. Given as fraction of the total system size.</dd>
<dt><strong><code>randomize</code></strong> :&ensp;<code>bool</code></dt>
<dd>The clustering processes is dependent on the order of
the points; if <code>randomize=True</code>, the provided array will
be indexed in a random order, otherwise it will be accessed
exactly as provided.</dd>
<dt><strong><code>wrapPoints</code></strong> :&ensp;<code>numpy.ndarray[d]</code> or <code>float</code> or <code>None</code></dt>
<dd>
<p>If the space is periodic, the size of each dimension. If
a single value is given, this will be used for all dimensions.</p>
<p>If None, no periodicity is assumed.</p>
<p>Can have a mix of periodic and non-periodic dimensions,
eg. spherical coordinates should have:
<code>wrapPoints=[None, 2*np.pi, np.pi]</code></p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>labels</code></strong> :&ensp;<code>numpy.ndarray[N]</code></dt>
<dd>Array of N labels (integers) denoting cluster
assignment. Total number of clusters will be <code>max(labels)+1</code>.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pepe.topology" href="index.html">pepe.topology</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pepe.topology.Clustering.spatialClusterCenters" href="#pepe.topology.Clustering.spatialClusterCenters">spatialClusterCenters</a></code></li>
<li><code><a title="pepe.topology.Clustering.spatialClusterLabels" href="#pepe.topology.Clustering.spatialClusterLabels">spatialClusterLabels</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
