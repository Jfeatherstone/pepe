<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>pepe.tracking.Convolution API documentation</title>
<meta name="description" content="Particle position tracking via convolution.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pepe.tracking.Convolution</code></h1>
</header>
<section id="section-intro">
<p>Particle position tracking via convolution.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pepe.tracking.Convolution.circularKernelFind"><code class="name flex">
<span>def <span class="ident">circularKernelFind</span></span>(<span>singleChannelFrame, radius, fftPadding, kernelBlurKernel=3, outlineOnly=False, outlineThickness=0.05, negativeHalo=False, haloThickness=0.03, negativeInside=False, paddingValue=None, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the convolution of a circular mask with an image,
identifying likely locations of circles within the image. Adapted from
method described in [1].</p>
<p>To perform the convolution, we take the product of the fft of each the
kernel and image, and then ifft the result to transform back to real space.
The only peculiarity is that there can be some issues with the edges of image
(especially if any circle centers are near the edge/off-screen) so we
have to take care to properly pad the image and the kernel.</p>
<p>Note that this method is not intended to be used as the front end for
circle detection for real data. The method <code>pepe.tracking.convCircle()</code>
makes use of this method to track circles, while also offering many more
features. It is recommended to use that function unless there is a very
specific purpose that it does not serve.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>singleChannelFrame</code></strong> :&ensp;<code>np.ndarray[H,W]</code></dt>
<dd>A single-channel image (grayscale or just one channel) within which we
are looking to identify circular objects.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of circles to detect in the image.</dd>
<dt><strong><code>fftPadding</code></strong> :&ensp;<code>int</code></dt>
<dd>The amount of padding to add to each side of the image, to prevent the
fft from having issues. A good choice is usually 1.5 times the radius,
though, less padding can be used if circles are not expected to often
be located near the edges.</dd>
<dt><strong><code>kernelBlurKernel</code></strong> :&ensp;<code>int</code></dt>
<dd>The kernel size to use to blur the kernel that will be convolved with the image, in
pixels. A value of 0 or None will use the original kernel.</dd>
<dt><strong><code>outlineOnly</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to look for only a particle outline (True), or to look for a filled-in circle (False).</p>
<p>See <code>outlineThickness</code>.</p>
</dd>
<dt><strong><code>outlineThickness</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>
<p>Thickness of the particle outline in the kernel; only relevant if <code>outlineOnly=True</code>.</p>
<p>If float, will be taken as fraction of the radius; if integer, will be taken as number
of pixels.</p>
</dd>
<dt><strong><code>negativeHalo</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to surround the particle mask with a region of negative value, which
further promotes identifying distinct objects as grains.</dd>
<dt><strong><code>haloThickness</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>
<p>Thickness of the negative halo in the kernel; only relevant if <code>negativeHalo=True</code>.</p>
<p>If float, will be taken as fraction of the radius; if integer, will be taken as number
of pixels.</p>
</dd>
<dt><strong><code>negativeInside</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to fill the inside of the particle mask with a negative value, which
further promotes identifying outlines of circles.</p>
<p>Has no effect unless <code>outlineOnly=True</code>.</p>
</dd>
<dt><strong><code>paddingValue</code></strong> :&ensp;<code>[float, </code>'sigmoid'<code>,</code> or <code><code>None&lt;/code&gt;]</code></dt>
<dd>
<p>What value to fill in for the extra padding that is added during the fft/ifft.</p>
<p><code>None</code> leaves the value at 0.</p>
<p><code>'sigmoid'</code> will create a smooth-ish transition to 0.</p>
<p>Any float value will be inserted into every point.</p>
</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to plot various quantities of the calculation for inspection
at the end of the evaluation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>chiSqr</code></strong> :&ensp;<code>np.ndarray[H,W]</code></dt>
<dd>The convolution of the kernel with the image. Larger values represent
higher likelihood that there is a particle centered there.</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Franklin, S. V., &amp; Shattuck, M. D. (Eds.). (2016). Handbook
of Granular Materials. Chapter 2: Experimental Techniques. p.64-68.
CRC Press. <a href="https://doi.org/10.1201/b19291">https://doi.org/10.1201/b19291</a></p></div>
</dd>
<dt id="pepe.tracking.Convolution.convCircle"><code class="name flex">
<span>def <span class="ident">convCircle</span></span>(<span>singleChannelFrame, radius, radiusTolerance=None, offscreenParticles=False, kernelBlurKernel=3, outlineOnly=False, outlineThickness=0.05, negativeHalo=False, haloThickness=0.03, negativeInside=False, peakDownsample=10, minPeakPrevalence=0.1, intensitySoftmax=1.2, intensitySoftmin=0.1, invert=False, allowOverlap=True, fitPeaks=True, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform convolution circle detection on the provided image.</p>
<p>A brief description of the technique is described below; for
a more comprehensive discussion, see [1].</p>
<p>The convolution method identifies circles in an image by convolving
a kernel (representing what a particle should look like) with the
image within which you would like to detect circles. This essentially
finds the likelihood of any particle location being the center for
such an object. By performing peak detection on this 2D quantity,
we can identify the most likely places for particles to be.</p>
<p>While this technique can be used for non-circular objects, this
implementation makes use of several simplifications/approximations
that make it suitable only for radially symmetric objects.</p>
<p>Tends to give more accurate and consistent results than the Hough
technique (see <code>pepe.tracking.houghCircle()</code>), though evaluation
times can be longer. When the radius of the circle is not well known
(with no initial guess), the Hough method should be used. That being said,
this implementation can fine tune the provided radius, but this requires
the provided value to be reasonably close to the actual value (within
~10 pixels is ideal).</p>
<p>The ability to get subpixel precision by interpolating/fitting curves to the
convolution is currently WIP, and currently the method can, at best, give results
accurate to within a single pixel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>singleChannelFrame</code></strong> :&ensp;<code>np.uint8[H, W]</code></dt>
<dd>The frame to perform circle detection on. Should not include multiple
color channels. If it does, the channels will be averaged to form a
grayscale image.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code> or <code>[float, float]</code></dt>
<dd>
<p>The radius to look for, or min and max radii to constrain the circle
detection. If a single value is provided, a range will be constructed
around that value with the <code>radiusTolerance</code> parameter.</p>
<p>Note that this method is more sensitive to the initial guess of radius
than <code>pepe.tracking.houghCircle()</code>. Ideally, the radius should be within
~10 pixels of the true radius (or a range of radii should only be ~15 pixels wide).</p>
<p>NOTE: Varying the radius is still under development, and likely does not work that great.</p>
</dd>
<dt><strong><code>radiusTolerance</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>
<p>The half-width of the range of radii that will be tested for detecting particles.
ie. the range will be calculated as <code>[radius + radiusTolerance, radius - radiusTolerance]</code>.</p>
<p>If set to <code>None</code>, radius will be fixed at whatever value is provided via <code>radius</code> argument.</p>
<p>NOTE: Varying the radius is still under development, and likely does not work that great.</p>
</dd>
<dt><strong><code>offscreenParticles</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether or not the algorithm should look for particles whose centers are outside of
the image domain (but some parts of the particles still show up in the image).</p>
<p>This expands the padding provided to the fft/ifft calculations, so as to avoid cutting
off what might be a potential particle. As a result, a value of True will increase computation times.</p>
</dd>
<dt><strong><code>outlineOnly</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to look for only a particle outline (True), or to look for a filled-in circle (False).</p>
<p>See <code>outlineThickness</code>.</p>
</dd>
<dt><strong><code>outlineThickness</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>
<p>Thickness of the particle outline in the kernel; only relevant if <code>outlineOnly=True</code>.</p>
<p>If float, will be taken as fraction of the radius; if integer, will be taken as number
of pixels.</p>
</dd>
<dt><strong><code>negativeHalo</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to surround the particle mask with a region of negative value, which
further promotes identifying distinct objects as grains.</dd>
<dt><strong><code>haloThickness</code></strong> :&ensp;<code>float</code> or <code>int</code></dt>
<dd>
<p>Thickness of the negative halo in the kernel; only relevant if <code>negativeHalo=True</code>.</p>
<p>If float, will be taken as fraction of the radius; if integer, will be taken as number
of pixels.</p>
</dd>
<dt><strong><code>negativeInside</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to fill the inside of the particle mask with a negative value, which
further promotes identifying outlines of circles.</p>
<p>Has no effect unless <code>outlineOnly=True</code>.</p>
</dd>
<dt><strong><code>peakDownsample</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>The factor by which to downsample the image when performing the initial peak
detection. The final peak detection will always be performed at the original
resolution, so this should not affect the accuracy of the detected circles,
though it is possible that some particles in a densely packed system may
not be detected. False</p>
<p>Set to <code>1</code> or <code>None</code> to perform no downsampling, though this is not recommended,
as the peak finding algorithm is O(N) where N is the total number of grid points.</p>
</dd>
<dt><strong><code>minPeakPrevalence</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>The minimum prevalence (or persistence) of peaks that will be considered as
particles. Should be a float in the range <code>[0, 1.]</code>, representing the percent
of the total intensity data range that must be spanned by a feature.</p>
<p>See <code>pepe.topology.findPeaks2D()</code> for more information.</p>
</dd>
<dt><strong><code>fitPeaks</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to fit each peak in the convolution with a lorentzian
form and use that center as the location of the particle (instead of
the simple maximum point).</dd>
<dt><strong><code>intensitySoftmax</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Value at which to cap the intensity values in the image, calculated as
this value multipled by the mean of the image.</p>
<p>Set to <code>None</code> to skip this preprocessing step.</p>
</dd>
<dt><strong><code>intensitySoftmin</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>Zero-out all values that have an intensity below this factor times the mean of
the image.</p>
<p>Set to <code>None</code> to skip this preprocessing step.</p>
</dd>
<dt><strong><code>allowOverlap</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to allow detections of particles that overlap. If set to
False, then the particle with the stronger signature will be kept</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to draw debug information on a plot.</dd>
<dt><strong><code>invert</code></strong> :&ensp;<code>bool</code></dt>
<dd>If particles appear dark on a bright background, this will invert the
image (and convolution peak finding will go from looking for maxima
to looking for minima).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>centers</code></strong> :&ensp;<code>np.ndarray[N,2]</code></dt>
<dd>The detected circles' centers.</dd>
<dt><strong><code>radii</code></strong> :&ensp;<code>np.ndarray[N]</code></dt>
<dd>The detected circles' radii.</dd>
</dl>
<h2 id="references">References</h2>
<p>[1] Franklin, S. V., &amp; Shattuck, M. D. (Eds.). (2016). Handbook
of Granular Materials. Chapter 2: Experimental Techniques. p.63-68.
CRC Press. <a href="https://doi.org/10.1201/b19291">https://doi.org/10.1201/b19291</a></p></div>
</dd>
<dt id="pepe.tracking.Convolution.genCircularKernel"><code class="name flex">
<span>def <span class="ident">genCircularKernel</span></span>(<span>center, radius, imageShape, kernelBlurKernel=3, outlineOnly=False, outlineThickness=0.05, negativeHalo=False, haloThickness=0.03, negativeInside=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pepe.tracking" href="index.html">pepe.tracking</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pepe.tracking.Convolution.circularKernelFind" href="#pepe.tracking.Convolution.circularKernelFind">circularKernelFind</a></code></li>
<li><code><a title="pepe.tracking.Convolution.convCircle" href="#pepe.tracking.Convolution.convCircle">convCircle</a></code></li>
<li><code><a title="pepe.tracking.Convolution.genCircularKernel" href="#pepe.tracking.Convolution.genCircularKernel">genCircularKernel</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
