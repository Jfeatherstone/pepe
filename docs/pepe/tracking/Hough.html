<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pepe.tracking.Hough API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pepe.tracking.Hough</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

import cv2
from scipy.ndimage import filters

import numba

from pepe.analysis import gSquared
from pepe.preprocess import sobelEdgeDetection, laplacianEdgeDetection, cannyEdgeDetection

import matplotlib.pyplot as plt

def houghCircle(singleChannelFrame, radius, edgeDetection=&#39;laplacian&#39;, blurKernel=None, cannyEdgeThreshold=70, accumulatorThreshold=20, radiusTolerance=15, minSeparation=None, draw=False):
    &#34;&#34;&#34;
    Perform Hough circle detection on the gradient squared of the provided image.

    Parameters
    ----------

    singleChannelFrame : np.uint8[H, W]
        The frame to perform circle detection on. Should not include multiple
        color channels.

    radius : float or [float, float]
        The approximate radius to look for, or a range of radii to look between.
        If a single value is provided, a range will be constructed around that
        value with the `radiusTolerance` parameter.

    edgeDetection : [&#39;sobel&#39;, &#39;laplacian&#39;, &#39;canny&#39;, None]
        What type of edge detection should be performed on the image before the hough
        algorithm is applied.

    cannyEdgeThreshold : float
        Value between 0 and 100 representing the threshold for edge detection. Smaller
        values means the edges of circles do not have to be as strongly defined, but
        this also means you may get false positive detections.

    accumulatorThreshold : float
        Value between 0 and 100 representing the threshold for the accumulator (how
        the Hough method votes on which objects are circles). Higher values should
        be used when circles are well defined, and lower values for weaker signals.

    radiusTolerance : float
        Value used to construct a radius interval assuming only a single value is
        passed for parameter `radius`. Interval will be [radius - radiusTolerance,
        radius + radiusTolerance].

    minSeparation : float
        The minimum distance allowed between detected circles. If None (the
        default value) this will be calculated as twice the radius minus the
        radius tolerance.

    draw : bool
        Whether or not to draw debug information on a plot.

    Returns
    -------

    centers : np.ndarray[N,2]
        The detected circles&#39; centers.

    radii : np.ndarray[N]
        The detected circles&#39; radii.
    &#34;&#34;&#34;

    # Check if we are given a range of radii or just a single value
    minRadius = None
    maxRadius = None

    if hasattr(radius, &#39;__iter__&#39;):
        if len(radius) == 2:
           minRadius = radius[0]
           maxRadius = radius[1]
    else:
        # Use the tolerance
        minRadius = radius - radiusTolerance
        maxRadius = radius + radiusTolerance


    if minRadius is None or maxRadius is None:
        raise Exception(&#39;Exception parsing expected radius!&#39;)

    if blurKernel is not None:
        blurredImage = cv2.blur(singleChannelFrame, (blurKernel, blurKernel))
    else:
        blurredImage = singleChannelFrame

    if edgeDetection == &#39;laplacian&#39;:
        detectImage = laplacianEdgeDetection(blurredImage)
    elif edgeDetection == &#39;sobel&#39;:
        detectImage = sobelEdgeDetection(blurredImage)
    elif edgeDetection == &#39;canny&#39;:
        detectImage = cannyEdgeDetection(blurredImage)
    else:
        detectImage = blurredImage


    # We don&#39;t expect too much overlap, so this should be a reasonable
    # separation distance
    if minSeparation is None:
        minSeparation = 2*minRadius - radiusTolerance

    detectedCircles = cv2.HoughCircles(np.array(detectImage, dtype=np.uint8), 
                    cv2.HOUGH_GRADIENT,
                    dp=1, # Accumulator (no idea what it does, but 1 is good)
                    minDist=minSeparation, # Minimum distance between circles
                    param1=cannyEdgeThreshold, # Threshold for canny edge detection
                    param2=accumulatorThreshold, # Accumulator threshold
                    minRadius=minRadius,
                    maxRadius=maxRadius)

    if detectedCircles is None:
        return np.array([]), np.array([])

    centers = np.array(list(zip(detectedCircles[0,:,1], detectedCircles[0,:,0])))
    radii = detectedCircles[0,:,2]


    if draw:
        fig, ax = plt.subplots(1, 3, figsize=(10,4))
        ax[0].imshow(singleChannelFrame)
        ax[0].set_title(&#39;Original image&#39;)

        ax[1].imshow(detectImage)
        ax[1].set_title(&#39;Detection image&#39;)

        ax[2].imshow(detectImage)
        ax[2].set_title(&#39;Detected circles&#39;)
        for i in range(len(centers)):
            c = plt.Circle(centers[i][::-1], radii[i], color=&#39;red&#39;, fill=False, linewidth=1)
            ax[2].add_artist(c)

        fig.tight_layout()
        plt.show()

    return centers, radii</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pepe.tracking.Hough.houghCircle"><code class="name flex">
<span>def <span class="ident">houghCircle</span></span>(<span>singleChannelFrame, radius, edgeDetection='laplacian', blurKernel=None, cannyEdgeThreshold=70, accumulatorThreshold=20, radiusTolerance=15, minSeparation=None, draw=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Perform Hough circle detection on the gradient squared of the provided image.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>singleChannelFrame</code></strong> :&ensp;<code>np.uint8[H, W]</code></dt>
<dd>The frame to perform circle detection on. Should not include multiple
color channels.</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code> or <code>[float, float]</code></dt>
<dd>The approximate radius to look for, or a range of radii to look between.
If a single value is provided, a range will be constructed around that
value with the <code>radiusTolerance</code> parameter.</dd>
<dt><strong><code>edgeDetection</code></strong> :&ensp;<code>['sobel', 'laplacian', 'canny', None]</code></dt>
<dd>What type of edge detection should be performed on the image before the hough
algorithm is applied.</dd>
<dt><strong><code>cannyEdgeThreshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Value between 0 and 100 representing the threshold for edge detection. Smaller
values means the edges of circles do not have to be as strongly defined, but
this also means you may get false positive detections.</dd>
<dt><strong><code>accumulatorThreshold</code></strong> :&ensp;<code>float</code></dt>
<dd>Value between 0 and 100 representing the threshold for the accumulator (how
the Hough method votes on which objects are circles). Higher values should
be used when circles are well defined, and lower values for weaker signals.</dd>
<dt><strong><code>radiusTolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>Value used to construct a radius interval assuming only a single value is
passed for parameter <code>radius</code>. Interval will be [radius - radiusTolerance,
radius + radiusTolerance].</dd>
<dt><strong><code>minSeparation</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum distance allowed between detected circles. If None (the
default value) this will be calculated as twice the radius minus the
radius tolerance.</dd>
<dt><strong><code>draw</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to draw debug information on a plot.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>centers</code></strong> :&ensp;<code>np.ndarray[N,2]</code></dt>
<dd>The detected circles' centers.</dd>
<dt><strong><code>radii</code></strong> :&ensp;<code>np.ndarray[N]</code></dt>
<dd>The detected circles' radii.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def houghCircle(singleChannelFrame, radius, edgeDetection=&#39;laplacian&#39;, blurKernel=None, cannyEdgeThreshold=70, accumulatorThreshold=20, radiusTolerance=15, minSeparation=None, draw=False):
    &#34;&#34;&#34;
    Perform Hough circle detection on the gradient squared of the provided image.

    Parameters
    ----------

    singleChannelFrame : np.uint8[H, W]
        The frame to perform circle detection on. Should not include multiple
        color channels.

    radius : float or [float, float]
        The approximate radius to look for, or a range of radii to look between.
        If a single value is provided, a range will be constructed around that
        value with the `radiusTolerance` parameter.

    edgeDetection : [&#39;sobel&#39;, &#39;laplacian&#39;, &#39;canny&#39;, None]
        What type of edge detection should be performed on the image before the hough
        algorithm is applied.

    cannyEdgeThreshold : float
        Value between 0 and 100 representing the threshold for edge detection. Smaller
        values means the edges of circles do not have to be as strongly defined, but
        this also means you may get false positive detections.

    accumulatorThreshold : float
        Value between 0 and 100 representing the threshold for the accumulator (how
        the Hough method votes on which objects are circles). Higher values should
        be used when circles are well defined, and lower values for weaker signals.

    radiusTolerance : float
        Value used to construct a radius interval assuming only a single value is
        passed for parameter `radius`. Interval will be [radius - radiusTolerance,
        radius + radiusTolerance].

    minSeparation : float
        The minimum distance allowed between detected circles. If None (the
        default value) this will be calculated as twice the radius minus the
        radius tolerance.

    draw : bool
        Whether or not to draw debug information on a plot.

    Returns
    -------

    centers : np.ndarray[N,2]
        The detected circles&#39; centers.

    radii : np.ndarray[N]
        The detected circles&#39; radii.
    &#34;&#34;&#34;

    # Check if we are given a range of radii or just a single value
    minRadius = None
    maxRadius = None

    if hasattr(radius, &#39;__iter__&#39;):
        if len(radius) == 2:
           minRadius = radius[0]
           maxRadius = radius[1]
    else:
        # Use the tolerance
        minRadius = radius - radiusTolerance
        maxRadius = radius + radiusTolerance


    if minRadius is None or maxRadius is None:
        raise Exception(&#39;Exception parsing expected radius!&#39;)

    if blurKernel is not None:
        blurredImage = cv2.blur(singleChannelFrame, (blurKernel, blurKernel))
    else:
        blurredImage = singleChannelFrame

    if edgeDetection == &#39;laplacian&#39;:
        detectImage = laplacianEdgeDetection(blurredImage)
    elif edgeDetection == &#39;sobel&#39;:
        detectImage = sobelEdgeDetection(blurredImage)
    elif edgeDetection == &#39;canny&#39;:
        detectImage = cannyEdgeDetection(blurredImage)
    else:
        detectImage = blurredImage


    # We don&#39;t expect too much overlap, so this should be a reasonable
    # separation distance
    if minSeparation is None:
        minSeparation = 2*minRadius - radiusTolerance

    detectedCircles = cv2.HoughCircles(np.array(detectImage, dtype=np.uint8), 
                    cv2.HOUGH_GRADIENT,
                    dp=1, # Accumulator (no idea what it does, but 1 is good)
                    minDist=minSeparation, # Minimum distance between circles
                    param1=cannyEdgeThreshold, # Threshold for canny edge detection
                    param2=accumulatorThreshold, # Accumulator threshold
                    minRadius=minRadius,
                    maxRadius=maxRadius)

    if detectedCircles is None:
        return np.array([]), np.array([])

    centers = np.array(list(zip(detectedCircles[0,:,1], detectedCircles[0,:,0])))
    radii = detectedCircles[0,:,2]


    if draw:
        fig, ax = plt.subplots(1, 3, figsize=(10,4))
        ax[0].imshow(singleChannelFrame)
        ax[0].set_title(&#39;Original image&#39;)

        ax[1].imshow(detectImage)
        ax[1].set_title(&#39;Detection image&#39;)

        ax[2].imshow(detectImage)
        ax[2].set_title(&#39;Detected circles&#39;)
        for i in range(len(centers)):
            c = plt.Circle(centers[i][::-1], radii[i], color=&#39;red&#39;, fill=False, linewidth=1)
            ax[2].add_artist(c)

        fig.tight_layout()
        plt.show()

    return centers, radii</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pepe.tracking" href="index.html">pepe.tracking</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pepe.tracking.Hough.houghCircle" href="#pepe.tracking.Hough.houghCircle">houghCircle</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>