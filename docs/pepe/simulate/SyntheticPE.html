<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pepe.simulate.SyntheticPE API documentation</title>
<meta name="description" content="Generate a synthetic photoelastic response." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pepe.simulate.SyntheticPE</code></h1>
</header>
<section id="section-intro">
<p>Generate a synthetic photoelastic response.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Generate a synthetic photoelastic response.
&#34;&#34;&#34;
import numpy as np

import numba

from pepe.preprocess import circularMask

# fastmath relaxes some of the floating point precision,
# and leads to an accumulated error of around 1e-10
# It doesn&#39;t speed up a ton, but this error is so small that
# any amount of speed up is worth it (I think it&#39;s about 5ms/evaluation)
@numba.njit(parallel=False, fastmath=True)
def genSyntheticResponse(forceArr, alphaArr, betaArr, fSigma, radius, pxPerMeter=1, brightfield=True, imageSize=None, center=None, mask=None):
    &#34;&#34;&#34;
    Generate the theoretical photoelastic response given the material
    properties and a set of forces.

    Based on Jonathan Kollmer&#39;s PeGS (matlab):
    https://github.com/jekollmer/PEGS

    and Olivier Lantsoght&#39;s PeGS_Py:
    https://git.immc.ucl.ac.be/olantsoght/pegs_py

    Parameters
    ----------

    forceArr : np.ndarray[Z]
        Array of force magnitudes acting on the particle (Z is number of contacts
        aka coordination number)

    alphaArr : np.ndarray[Z]
        Array of angles representing force contact angles.

    betaArr : np.ndarray[Z]
        Array of angles representing force contact positions.

    fSigma : float
        Stress optic coefficient, relating to material thickness, wavelength of light
        and other material property (C).

    radius : float
        Radius of the particle that is being simulated in pixels. If pxPerMeter is
        set to None, this value will be assumed to already have been converted to meters.

    pxPerMeter : float
        The number of pixels per meter for the simulated image. If not provided (or set to 1), the radius
        value will be assumed to already have been converted to meters.

    brightfield : bool
        Whether the intensity should be simulated as seen through a brightfield (True)
        polariscope or darkfield (False) polariscope.

    imageSize : [int, int]
        The size of the canvas the stress pattern will be drawn on. Set to None to automatically
        determine this based on the radius.

    center : [int, int]
        Where the center of the particle should be position in on the image canvas. Useful for
        creating a composite image of many particles, as the final image can be made just by
        adding each individual matrix together. Set to None to center the particle automatically.

    mask : np.uint8[H,W]
        Array of values representing which points, within the circle, to calculate the intensity
        for. Points with non-zero value represented desired points, and locations with value of
        0 will not be calculated.

        Points with value of 1 outside of the circular particle will be ignored.

    &#34;&#34;&#34;

    # Deal with parameters about the image
    # Note that it is very helpful to have an odd size, such that there is
    # a central pixel
    if imageSize is None:
        # 11 is arbitrary, just a small, odd number
        imageSize = (np.int16(radius*2)+11, np.int16(radius*2)+11)

    if center is None:
        center = np.array([imageSize[0]/2, imageSize[1]/2], dtype=np.int64)

    if mask is None:
        mask = circularMask(imageSize, center, radius)[:,:,0]

    # Create a mask representing the particle, to find the points we need
    # to simulate
    particleMask = circularMask(imageSize, center, radius)[:,:,0]
    # Grab every point inside the circle

    # Normally we could just do this:
    #points = np.transpose(np.where(cMask &gt; 0))
    # but numba doesn&#39;t quite like this way, so we have to be 
    # a little more creative
    fullMask = particleMask + mask
    whereIndices = np.where(fullMask &gt; 1)
    points = np.zeros((len(whereIndices[0]), 2), dtype=np.int16)
    # There is a chance that these indices are backwards, but
    # because we have rotational symmetry, it doesn&#39;t really matter...
    # BUT if there is ever some weird anisotropy bug or something,
    # try switching these indices
    points[:,0] = whereIndices[0]
    points[:,1] = whereIndices[1]

    intensityArr = np.zeros((imageSize[0], imageSize[1]))

    # As per conventions through the rest of the library, order of points is y,x
    for i in numba.prange(points.shape[0]):
        # While we index for the points on the entire grid,
        # we have to pass the stress evaluation method the position relative
        # to the center of the partice
        intensityArr[points[i,0],points[i,1]] = evaluateStress(points[i,0]-center[0], points[i,1]-center[1], forceArr, alphaArr, betaArr, fSigma, radius, pxPerMeter, brightfield)

    return intensityArr
    

# See genSyntheticResponse note about fastmath
@numba.njit(fastmath=True)
def evaluateStress(yInd, xInd, forceArr, alphaArr, betaArr, fSigma, radius, pxPerMeter, brightfield=True):
    &#34;&#34;&#34;
    Evaluate the stress (and resulting photoelastic intensity) at a particular point within
    a particle subject to a set of forces. 

    No checks are done to insure that the point provided is within the particle itself -- this
    should be done externally.

    Parameters
    ----------

    yInd : int
        The indexed y of the point we are computing the stress for, relative
        to the center of the particle.

    xInd : int
        The indexed x of the point we are computing the stress for, relative
        to the center of the particle.

    forceArr : np.ndarray[Z]
        Array of force magnitudes acting on the particle (Z is number of contacts,
        aka coordination number).

    alphaArr : np.ndarray[Z]
        Array of angles representing force contact angles.

    betaArr : np.ndarray[Z]
        Array of angles representing force contact positions.

    fSigma : float
        Stress optic coefficient, relating to material thickness, wavelength of light
        and other material property (C).

    radius : float
        Radius of the particle that is being simulated in pixels. If pxPerMeter is
        set to None, this value will be assumed to already have been converted to meters.

    pxPerMeter : float
        The number of pixels per meter for the simulated image. While not recommended,
        set value to 1 if the positions and radius have already been converted to meters.

    brightfield : bool
        Whether the intensity should be simulated as seen through a brightfield (True)
        polariscope or darkfield (False) polariscope.
        
    &#34;&#34;&#34;
    # We expect that distance/position values are NOT in physical units yet
    # so we have to divide by pxPerMeter to get real values
    xM = xInd/pxPerMeter
    yM = yInd/pxPerMeter
    radiusM = radius/pxPerMeter

    # Coordination number
    z = len(forceArr)

    # Iterate over each force, and calculate the total stress
    # attributed to that force (at the given point)
    sigmaXX, sigmaXY, sigmaYY = 0,0,0
    for i in range(z):
        # Adjust beta for rotation to match the real images we are working with
        b1 = -betaArr[i] + np.pi
        # The middle expression is really just the sign function, but we
        # need sign(0)=1 (sign(0)=0 by default) so we do a little
        # boolean magic
        b2 = b1 - (-1 + 2*int(np.sign(alphaArr[i]) &gt; -1)) * np.pi + 2*alphaArr[i]

        # Calculate the length of the chord
        chordX = radiusM * (np.sin(b2) - np.sin(b1))
        chordY = radiusM * (np.cos(b2) - np.cos(b1))
        chordLength = np.sqrt(chordX**2 + chordY**2)

        # Calculate the vector for the given position to the chord
        vecX = xM - radiusM*np.sin(b1)
        vecY = -yM - radiusM*np.cos(b1) # Not sure why there is negative here
        rVec = np.sqrt(vecX**2 + vecY**2)

        # Error check
        # See if either the vector or the chord length is zero
        if rVec*chordLength == 0.:
            #print(&#34;Bad length&#34;)
            return 0.

        # Normalize the components of the chord
        chordX /= chordLength
        chordY /= chordLength

        arccosArgument = (vecX*chordX + vecY*chordY) / rVec

        # At the very center, this argument will be almost exactly 1,
        # but we&#39;ll get a nan if it is exactly 1, so we need to subtract a little
        # bit slightly above the order of machine error
        # This is most likely the issue that Jonathan commented about in his code
        #arccosArgument -= np.float64(xInd+yInd + xInd*yInd == 0)*1e-10
        arccosArgument -= 1e-10

        th = np.sign(vecY*chordX - vecX*chordY) * np.arccos(arccosArgument)

        s1 = -2/np.pi * forceArr[i]*arccosArgument / rVec
        s2 = -1/(np.pi*radiusM) * forceArr[i] * (-np.sin(alphaArr[i]))
        sr = s1 - s2

        th += betaArr[i] - np.pi/2 - alphaArr[i]

        sigmaXX += sr*np.sin(th)**2
        sigmaYY += sr*np.cos(th)**2
        sigmaXY += 0.5*s1*np.sin(2*th)

    pressureDiff = sigmaXX - sigmaYY
    principleStressDiff = np.sqrt(pressureDiff**2 + 4*sigmaXY**2)

    # Brightfield vs darkfield we use cos vs sin
    if brightfield:
        return np.cos(np.pi/fSigma * principleStressDiff)**2
    else:
        return np.sin(np.pi/fSigma * principleStressDiff)**2</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pepe.simulate.SyntheticPE.evaluateStress"><code class="name flex">
<span>def <span class="ident">evaluateStress</span></span>(<span>yInd, xInd, forceArr, alphaArr, betaArr, fSigma, radius, pxPerMeter, brightfield=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Evaluate the stress (and resulting photoelastic intensity) at a particular point within
a particle subject to a set of forces. </p>
<p>No checks are done to insure that the point provided is within the particle itself &ndash; this
should be done externally.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>yInd</code></strong> :&ensp;<code>int</code></dt>
<dd>The indexed y of the point we are computing the stress for, relative
to the center of the particle.</dd>
<dt><strong><code>xInd</code></strong> :&ensp;<code>int</code></dt>
<dd>The indexed x of the point we are computing the stress for, relative
to the center of the particle.</dd>
<dt><strong><code>forceArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of force magnitudes acting on the particle (Z is number of contacts,
aka coordination number).</dd>
<dt><strong><code>alphaArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of angles representing force contact angles.</dd>
<dt><strong><code>betaArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of angles representing force contact positions.</dd>
<dt><strong><code>fSigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Stress optic coefficient, relating to material thickness, wavelength of light
and other material property (C).</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the particle that is being simulated in pixels. If pxPerMeter is
set to None, this value will be assumed to already have been converted to meters.</dd>
<dt><strong><code>pxPerMeter</code></strong> :&ensp;<code>float</code></dt>
<dd>The number of pixels per meter for the simulated image. While not recommended,
set value to 1 if the positions and radius have already been converted to meters.</dd>
<dt><strong><code>brightfield</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the intensity should be simulated as seen through a brightfield (True)
polariscope or darkfield (False) polariscope.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(fastmath=True)
def evaluateStress(yInd, xInd, forceArr, alphaArr, betaArr, fSigma, radius, pxPerMeter, brightfield=True):
    &#34;&#34;&#34;
    Evaluate the stress (and resulting photoelastic intensity) at a particular point within
    a particle subject to a set of forces. 

    No checks are done to insure that the point provided is within the particle itself -- this
    should be done externally.

    Parameters
    ----------

    yInd : int
        The indexed y of the point we are computing the stress for, relative
        to the center of the particle.

    xInd : int
        The indexed x of the point we are computing the stress for, relative
        to the center of the particle.

    forceArr : np.ndarray[Z]
        Array of force magnitudes acting on the particle (Z is number of contacts,
        aka coordination number).

    alphaArr : np.ndarray[Z]
        Array of angles representing force contact angles.

    betaArr : np.ndarray[Z]
        Array of angles representing force contact positions.

    fSigma : float
        Stress optic coefficient, relating to material thickness, wavelength of light
        and other material property (C).

    radius : float
        Radius of the particle that is being simulated in pixels. If pxPerMeter is
        set to None, this value will be assumed to already have been converted to meters.

    pxPerMeter : float
        The number of pixels per meter for the simulated image. While not recommended,
        set value to 1 if the positions and radius have already been converted to meters.

    brightfield : bool
        Whether the intensity should be simulated as seen through a brightfield (True)
        polariscope or darkfield (False) polariscope.
        
    &#34;&#34;&#34;
    # We expect that distance/position values are NOT in physical units yet
    # so we have to divide by pxPerMeter to get real values
    xM = xInd/pxPerMeter
    yM = yInd/pxPerMeter
    radiusM = radius/pxPerMeter

    # Coordination number
    z = len(forceArr)

    # Iterate over each force, and calculate the total stress
    # attributed to that force (at the given point)
    sigmaXX, sigmaXY, sigmaYY = 0,0,0
    for i in range(z):
        # Adjust beta for rotation to match the real images we are working with
        b1 = -betaArr[i] + np.pi
        # The middle expression is really just the sign function, but we
        # need sign(0)=1 (sign(0)=0 by default) so we do a little
        # boolean magic
        b2 = b1 - (-1 + 2*int(np.sign(alphaArr[i]) &gt; -1)) * np.pi + 2*alphaArr[i]

        # Calculate the length of the chord
        chordX = radiusM * (np.sin(b2) - np.sin(b1))
        chordY = radiusM * (np.cos(b2) - np.cos(b1))
        chordLength = np.sqrt(chordX**2 + chordY**2)

        # Calculate the vector for the given position to the chord
        vecX = xM - radiusM*np.sin(b1)
        vecY = -yM - radiusM*np.cos(b1) # Not sure why there is negative here
        rVec = np.sqrt(vecX**2 + vecY**2)

        # Error check
        # See if either the vector or the chord length is zero
        if rVec*chordLength == 0.:
            #print(&#34;Bad length&#34;)
            return 0.

        # Normalize the components of the chord
        chordX /= chordLength
        chordY /= chordLength

        arccosArgument = (vecX*chordX + vecY*chordY) / rVec

        # At the very center, this argument will be almost exactly 1,
        # but we&#39;ll get a nan if it is exactly 1, so we need to subtract a little
        # bit slightly above the order of machine error
        # This is most likely the issue that Jonathan commented about in his code
        #arccosArgument -= np.float64(xInd+yInd + xInd*yInd == 0)*1e-10
        arccosArgument -= 1e-10

        th = np.sign(vecY*chordX - vecX*chordY) * np.arccos(arccosArgument)

        s1 = -2/np.pi * forceArr[i]*arccosArgument / rVec
        s2 = -1/(np.pi*radiusM) * forceArr[i] * (-np.sin(alphaArr[i]))
        sr = s1 - s2

        th += betaArr[i] - np.pi/2 - alphaArr[i]

        sigmaXX += sr*np.sin(th)**2
        sigmaYY += sr*np.cos(th)**2
        sigmaXY += 0.5*s1*np.sin(2*th)

    pressureDiff = sigmaXX - sigmaYY
    principleStressDiff = np.sqrt(pressureDiff**2 + 4*sigmaXY**2)

    # Brightfield vs darkfield we use cos vs sin
    if brightfield:
        return np.cos(np.pi/fSigma * principleStressDiff)**2
    else:
        return np.sin(np.pi/fSigma * principleStressDiff)**2</code></pre>
</details>
</dd>
<dt id="pepe.simulate.SyntheticPE.genSyntheticResponse"><code class="name flex">
<span>def <span class="ident">genSyntheticResponse</span></span>(<span>forceArr, alphaArr, betaArr, fSigma, radius, pxPerMeter=1, brightfield=True, imageSize=None, center=None, mask=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the theoretical photoelastic response given the material
properties and a set of forces.</p>
<p>Based on Jonathan Kollmer's PeGS (matlab):
<a href="https://github.com/jekollmer/PEGS">https://github.com/jekollmer/PEGS</a></p>
<p>and Olivier Lantsoght's PeGS_Py:
<a href="https://git.immc.ucl.ac.be/olantsoght/pegs_py">https://git.immc.ucl.ac.be/olantsoght/pegs_py</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>forceArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of force magnitudes acting on the particle (Z is number of contacts
aka coordination number)</dd>
<dt><strong><code>alphaArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of angles representing force contact angles.</dd>
<dt><strong><code>betaArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of angles representing force contact positions.</dd>
<dt><strong><code>fSigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Stress optic coefficient, relating to material thickness, wavelength of light
and other material property (C).</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the particle that is being simulated in pixels. If pxPerMeter is
set to None, this value will be assumed to already have been converted to meters.</dd>
<dt><strong><code>pxPerMeter</code></strong> :&ensp;<code>float</code></dt>
<dd>The number of pixels per meter for the simulated image. If not provided (or set to 1), the radius
value will be assumed to already have been converted to meters.</dd>
<dt><strong><code>brightfield</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the intensity should be simulated as seen through a brightfield (True)
polariscope or darkfield (False) polariscope.</dd>
<dt><strong><code>imageSize</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>The size of the canvas the stress pattern will be drawn on. Set to None to automatically
determine this based on the radius.</dd>
<dt><strong><code>center</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>Where the center of the particle should be position in on the image canvas. Useful for
creating a composite image of many particles, as the final image can be made just by
adding each individual matrix together. Set to None to center the particle automatically.</dd>
<dt><strong><code>mask</code></strong> :&ensp;<code>np.uint8[H,W]</code></dt>
<dd>
<p>Array of values representing which points, within the circle, to calculate the intensity
for. Points with non-zero value represented desired points, and locations with value of
0 will not be calculated.</p>
<p>Points with value of 1 outside of the circular particle will be ignored.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit(parallel=False, fastmath=True)
def genSyntheticResponse(forceArr, alphaArr, betaArr, fSigma, radius, pxPerMeter=1, brightfield=True, imageSize=None, center=None, mask=None):
    &#34;&#34;&#34;
    Generate the theoretical photoelastic response given the material
    properties and a set of forces.

    Based on Jonathan Kollmer&#39;s PeGS (matlab):
    https://github.com/jekollmer/PEGS

    and Olivier Lantsoght&#39;s PeGS_Py:
    https://git.immc.ucl.ac.be/olantsoght/pegs_py

    Parameters
    ----------

    forceArr : np.ndarray[Z]
        Array of force magnitudes acting on the particle (Z is number of contacts
        aka coordination number)

    alphaArr : np.ndarray[Z]
        Array of angles representing force contact angles.

    betaArr : np.ndarray[Z]
        Array of angles representing force contact positions.

    fSigma : float
        Stress optic coefficient, relating to material thickness, wavelength of light
        and other material property (C).

    radius : float
        Radius of the particle that is being simulated in pixels. If pxPerMeter is
        set to None, this value will be assumed to already have been converted to meters.

    pxPerMeter : float
        The number of pixels per meter for the simulated image. If not provided (or set to 1), the radius
        value will be assumed to already have been converted to meters.

    brightfield : bool
        Whether the intensity should be simulated as seen through a brightfield (True)
        polariscope or darkfield (False) polariscope.

    imageSize : [int, int]
        The size of the canvas the stress pattern will be drawn on. Set to None to automatically
        determine this based on the radius.

    center : [int, int]
        Where the center of the particle should be position in on the image canvas. Useful for
        creating a composite image of many particles, as the final image can be made just by
        adding each individual matrix together. Set to None to center the particle automatically.

    mask : np.uint8[H,W]
        Array of values representing which points, within the circle, to calculate the intensity
        for. Points with non-zero value represented desired points, and locations with value of
        0 will not be calculated.

        Points with value of 1 outside of the circular particle will be ignored.

    &#34;&#34;&#34;

    # Deal with parameters about the image
    # Note that it is very helpful to have an odd size, such that there is
    # a central pixel
    if imageSize is None:
        # 11 is arbitrary, just a small, odd number
        imageSize = (np.int16(radius*2)+11, np.int16(radius*2)+11)

    if center is None:
        center = np.array([imageSize[0]/2, imageSize[1]/2], dtype=np.int64)

    if mask is None:
        mask = circularMask(imageSize, center, radius)[:,:,0]

    # Create a mask representing the particle, to find the points we need
    # to simulate
    particleMask = circularMask(imageSize, center, radius)[:,:,0]
    # Grab every point inside the circle

    # Normally we could just do this:
    #points = np.transpose(np.where(cMask &gt; 0))
    # but numba doesn&#39;t quite like this way, so we have to be 
    # a little more creative
    fullMask = particleMask + mask
    whereIndices = np.where(fullMask &gt; 1)
    points = np.zeros((len(whereIndices[0]), 2), dtype=np.int16)
    # There is a chance that these indices are backwards, but
    # because we have rotational symmetry, it doesn&#39;t really matter...
    # BUT if there is ever some weird anisotropy bug or something,
    # try switching these indices
    points[:,0] = whereIndices[0]
    points[:,1] = whereIndices[1]

    intensityArr = np.zeros((imageSize[0], imageSize[1]))

    # As per conventions through the rest of the library, order of points is y,x
    for i in numba.prange(points.shape[0]):
        # While we index for the points on the entire grid,
        # we have to pass the stress evaluation method the position relative
        # to the center of the partice
        intensityArr[points[i,0],points[i,1]] = evaluateStress(points[i,0]-center[0], points[i,1]-center[1], forceArr, alphaArr, betaArr, fSigma, radius, pxPerMeter, brightfield)

    return intensityArr</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pepe.simulate" href="index.html">pepe.simulate</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pepe.simulate.SyntheticPE.evaluateStress" href="#pepe.simulate.SyntheticPE.evaluateStress">evaluateStress</a></code></li>
<li><code><a title="pepe.simulate.SyntheticPE.genSyntheticResponse" href="#pepe.simulate.SyntheticPE.genSyntheticResponse">genSyntheticResponse</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>