<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pepe.utils.RectArr API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pepe.utils.RectArr</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np

from pepe.utils import preserveOrderArgsort

def rectangularizeForceArrays(forceArr, alphaArr, betaArr, centerArr, radiusArr, maxBetaDisplacement=.3, forcePadValue=np.nan, continuousBetas=False):
    &#34;&#34;&#34;
    Take the ragged arrays representing particles and forces and convert them to
    particle-wise rectangular arrays.

    The force input arrays should be 3 dimensional, with indices as follows:

        `forceArr[timestep index]
                [particle index]
                [force index]`

    The center array should be 3 dimensional as well, with indices as follows:

        `centerArr[timestep index]
                 [particle index]
                 [coordination (x or y) index]`

    The radius array should be 2 dimensional:

        `radiusArr[timestep index]
                 [particle index]`

    The final returned result will be a list of rectangular arrays of the form:

        `rectForceArr[particle index]
                    [force index]
                    [timestep index]`

    There are several advantages to restructing like this:

        1.  The evolution of a single force can be plotted with something
            like `plt.plot(rectForceArr[0][0])`. To do this with the input arrays
            would require quite a bit more work since they are lists, and cannot
            be sliced.
        
        2.  While the top-layer index corresponds to a python list, all of the particle-
            wise arrays are numpy objects, which allows them to be sliced/saved easily.

        3.  Due to potentially having different numbers of particles per frame and different
            numbers of forces acting on each particle, the original arrays and very ragged.
            This makes any sane indexing very hard to do, which is fixed by reshaping the
            arrays. If a force only exists for a subset of the time steps, the rectangular
            result will still identify it as a unique force in all timesteps, just with a
            magnitude of 0 (or `np.nan`; see `forcePadValue`).


    Parameters
    ----------

    forceArr : list[T,P,F]
        Force magnitudes for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
        per particle.

    alphaArr : list[T,P,F]
        Alpha angles for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
        per particle.

    betaArr : list[T,P,F]
        Beta angles for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
        per particle.

    centerArr : list[T,P,2]
        List of particle centers (y,x) for T timesteps, with P(T) particles per timestep.

    radiusArr : list[T,P]
        List of particle radii for T timesteps, with P(T) particles per timestep.

    angleArr : list[T,P]
        List of particle rotations for T timesteps, with P(T) particles per timestep.

    maxBetaDisplacement : float
        The maximum difference of beta angle between timesteps for which a force will
        still be identified with the previous step. The difference is calculated between
        the current timestep and whatever the last timestep for which that force existed.

    forcePadValue : float
        The value that is recorded for a force that isn&#39;t current active for a given frame.
        Common choices would be `np.nan` -- such that the force won&#39;t appear when it is
        plotted -- or `0` -- which is a little more physically-inspired.

    continuousBetas : bool
        When a force is not active for a number of timesteps, should the beta value (position)
        of that force be set to `np.nan` (`False`) or should the previous position of the
        force be carried over (`True`)? This is the difference between the force not existing
        for these timesteps, versus the force existing but having a magnitude of 0.

    Returns
    -------

    rectForceArr : list[P](np.ndarray[F,T])
        A list of arrays representing the force magnitude for each force on each particle.
        See description for more info.

    rectAlphaArr : list[P](np.ndarray[F,T])
        A list of arrays representing the alpha angle for each force on each particle.
        See description for more info.

    rectBetaArr : list[P](np.ndarray[F,T])
        A list of arrays representing the beta angle for force on each particle.
        See description for more info.

    rectCenterArr : np.ndarray[P,T,2]
        Particle centers for each timestep. Elements take on a value of `[np.nan, np.nan]`
        if the particle does not exist for a given timestep.

    rectRadiusArr : np.ndarray[P,T]
        Particle radii for each timestep. Elements take on a value of `np.nan` if the particle
        does not exist for a given timestep.

    rectAngleArr : np.ndarray[P,T]
        Particle angles for each timestep. Elements take on a value of `np.nan` if the particle
        does not exist for a given timestep.
    &#34;&#34;&#34;
    rectForceArr = []
    rectBetaArr = []
    rectAlphaArr = []

    # Scalar
    # TODO Make this capable of following same process as for forces, where
    # identities are maintained even if multiple particles appear/disappear
    maxNumParticles = np.max([len(betaArr[i]) for i in range(len(betaArr))])
    numTimesteps = len(forceArr)
    # First, make the centers array look nice, which we then use to identify
    # particles
    rectCenterArr = np.zeros((maxNumParticles, numTimesteps, 2))
    rectRadiusArr = np.zeros((maxNumParticles, numTimesteps))
    #rectAngleArr = np.zeros((maxNumParticles, numTimesteps))

    # We have to initialize the first element so that we can then use the
    # preserveOrderSort function to make sure the identities stay
    # consistent
    rectCenterArr[:,0] = list(centerArr[0]) + [[np.nan, np.nan]]*(maxNumParticles - len(centerArr[0]))
    rectRadiusArr[:,0] = list(radiusArr[0]) + [np.nan]*(maxNumParticles - len(centerArr[0]))
    #rectAngleArr[:,0] = list(angleArr[0]) + [np.nan]*(maxNumParticles - len(centerArr[0]))

    particleOrder = np.zeros((numTimesteps, maxNumParticles), dtype=np.int16)
    particleOrder[0] = np.arange(len(particleOrder[0]))
    particleExists = np.zeros((numTimesteps, maxNumParticles), dtype=np.int16)

    for i in range(1, numTimesteps):
        currOrder = preserveOrderArgsort(rectCenterArr[:,i-1], centerArr[i], padMissingValues=True, fillNanSpots=True)
        # Convert all None to -1 (since None can&#39;t be turned into an integer)
        particleOrder[i] = [ci if ci is not None else -1 for ci in currOrder]
        rectCenterArr[:,i] = [centerArr[i][particleOrder[i,j]] if particleOrder[i,j] &gt;= 0 else [np.nan, np.nan] for j in range(len(particleOrder[i]))]
        rectRadiusArr[:,i] = [radiusArr[i][particleOrder[i,j]] if particleOrder[i,j] &gt;= 0 else np.nan for j in range(len(particleOrder[i]))]
        #rectAngleArr[:,i] = [angleArr[i][particleOrder[i,j]] if particleOrder[i,j] &gt;= 0 else np.nan for j in range(len(particleOrder[i]))]

    # The angles were actually just changes in angle, so we should do a cumulative sum
    # using arange because we want to go backwards
    #for i in np.arange(1, numTimesteps)[::-1]:
    #    rectAngleArr[:,i] = np.sum(rectAngleArr[:,:i], axis=-1)

    # We now have linked the particles from frame to frame, and can
    # rectangularize the other quantities on a particle-by-particle basis
    for i in range(maxNumParticles):
        # Unfortunately, we cannot determine the maximum number of forces just by doing a
        # call to np.max(len(...)) or something, because eg. two frames could have 3 and 4
        # forces in each, but those could represent up to 7 unique forces total

        # This will be triangular array representing the indices of each force in the final
        # rectangular array
        # We have to make sure this particle exists at the first timestep as well
        #print(particleOrder[0])
        #print(betaArr[0])
        if particleOrder[0,i] &gt;= 0 and particleOrder[0,i] &lt; len(betaArr[0]):
            triSortedBetaArr = [betaArr[0][particleOrder[0,i]]]
            triSortedForceOrderArr = [list(np.arange(len(triSortedBetaArr[0])))]
        else:
            # Otherwise, we just use an empty list
            triSortedBetaArr = [[]]
            triSortedForceOrderArr = [[]]


        for j in range(1, numTimesteps):
            particleIndex = particleOrder[j,i]
   
            # If less than 0, that means this particle is not actually present in this
            # frame, so we just continue. Note that we do have to carry forward the
            # beta values from the previous frame, since otherwise we will run into
            # issues later on.
            if particleIndex &lt; 0:
                triSortedBetaArr.append(triSortedBetaArr[-1])
                triSortedForceOrderArr.append([None for i in range(len(triSortedBetaArr[-1]))])
                continue

            # Correlate the particles between this frame and the last
            #print(triSortedBetaArr[-1])
            order = preserveOrderArgsort(triSortedBetaArr[-1], betaArr[j][particleIndex], padMissingValues=True, maxDistance=maxBetaDisplacement, periodic=True)
            # If we &#34;lose&#34; a force, carry the old beta value through to the new array, so
            # that we can identify it if it ever pops up again.
            betaValues = [betaArr[j][particleIndex][order[k]] if order[k] is not None else triSortedBetaArr[-1][k] for k in range(len(order))]
            #print(betaValues)
            triSortedBetaArr.append(betaValues)
            #triSortedForceOrderArr.append([i for i in order if i is not None])
            triSortedForceOrderArr.append(order)

        # Since the triangular array is only allowed to grow, the length of the last
        # entry will be the maximum number of *unique* forces.
        #plt.plot([len(ele) for ele in triSortedBetaArr]) # Check that it only grows
        #plt.show()
        maxNumForces = len(triSortedBetaArr[-1])

        # Now we can finally create some nice rectangular arrays
        singleParticleForceArr = np.zeros((maxNumForces, numTimesteps))
        singleParticleBetaArr = np.zeros((maxNumForces, numTimesteps))
        singleParticleAlphaArr = np.zeros((maxNumForces, numTimesteps))

        for j in range(numTimesteps):
            particleIndex = particleOrder[j,i]

            # If particle doesn&#39;t exist for this frame, fill with nan values and move
            # on
            if particleIndex &lt; 0:
                singleParticleBetaArr[:,j] = np.repeat(np.nan, maxNumForces)
                singleParticleForceArr[:,j] = np.repeat(forcePadValue, maxNumForces)
                singleParticleAlphaArr[:,j] = np.repeat(np.nan, maxNumForces)
                continue

            # We want to remove the carry over beta values for forces that aren&#39;t actually there
            # now, and then pad with nan values for forces that haven&#39;t appeared yet

            # Not sure why, but it may be helpful to have the previous beta values carried over,
            # so that can be done by passing a kwarg
            if continuousBetas:
                singleParticleBetaArr[:,j] = [triSortedBetaArr[j][k] for k in range(len(triSortedBetaArr[j]))] + [np.nan]*(maxNumForces - len(triSortedBetaArr[j]))
            else:
                singleParticleBetaArr[:,j] = [betaArr[j][particleIndex][triSortedForceOrderArr[j][k]] if triSortedForceOrderArr[j][k] is not None else np.nan for k in range(len(triSortedBetaArr[j]))] + [np.nan]*(maxNumForces - len(triSortedBetaArr[j]))

            # I apologize to anyone who has to read these lines... They do exactly what is stated above,
            # but boy do they look terrible
            singleParticleForceArr[:,j] = [forceArr[j][particleIndex][triSortedForceOrderArr[j][k]] if triSortedForceOrderArr[j][k] is not None else forcePadValue for k in range(len(triSortedBetaArr[j]))] + [forcePadValue]*(maxNumForces - len(triSortedBetaArr[j]))
            singleParticleAlphaArr[:,j] = [alphaArr[j][particleIndex][triSortedForceOrderArr[j][k]] if triSortedForceOrderArr[j][k] is not None else np.nan for k in range(len(triSortedBetaArr[j]))] + [np.nan]*(maxNumForces - len(triSortedBetaArr[j]))

        # Append all of the nice rectangular arrays
        rectForceArr.append(singleParticleForceArr)
        rectAlphaArr.append(singleParticleAlphaArr)
        rectBetaArr.append(singleParticleBetaArr)

    return rectForceArr, rectAlphaArr, rectBetaArr, rectCenterArr, rectRadiusArr#, rectAngleArr</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pepe.utils.RectArr.rectangularizeForceArrays"><code class="name flex">
<span>def <span class="ident">rectangularizeForceArrays</span></span>(<span>forceArr, alphaArr, betaArr, centerArr, radiusArr, maxBetaDisplacement=0.3, forcePadValue=nan, continuousBetas=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Take the ragged arrays representing particles and forces and convert them to
particle-wise rectangular arrays.</p>
<p>The force input arrays should be 3 dimensional, with indices as follows:</p>
<pre><code>`forceArr[timestep index]
        [particle index]
        [force index]`
</code></pre>
<p>The center array should be 3 dimensional as well, with indices as follows:</p>
<pre><code>`centerArr[timestep index]
         [particle index]
         [coordination (x or y) index]`
</code></pre>
<p>The radius array should be 2 dimensional:</p>
<pre><code>`radiusArr[timestep index]
         [particle index]`
</code></pre>
<p>The final returned result will be a list of rectangular arrays of the form:</p>
<pre><code>`rectForceArr[particle index]
            [force index]
            [timestep index]`
</code></pre>
<p>There are several advantages to restructing like this:</p>
<pre><code>1.  The evolution of a single force can be plotted with something
    like &lt;code&gt;plt.plot(rectForceArr\[0]\[0])&lt;/code&gt;. To do this with the input arrays
    would require quite a bit more work since they are lists, and cannot
    be sliced.

2.  While the top-layer index corresponds to a python list, all of the particle-
    wise arrays are numpy objects, which allows them to be sliced/saved easily.

3.  Due to potentially having different numbers of particles per frame and different
    numbers of forces acting on each particle, the original arrays and very ragged.
    This makes any sane indexing very hard to do, which is fixed by reshaping the
    arrays. If a force only exists for a subset of the time steps, the rectangular
    result will still identify it as a unique force in all timesteps, just with a
    magnitude of 0 (or &lt;code&gt;np.nan&lt;/code&gt;; see &lt;code&gt;forcePadValue&lt;/code&gt;).
</code></pre>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>forceArr</code></strong> :&ensp;<code>list[T,P,F]</code></dt>
<dd>Force magnitudes for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
per particle.</dd>
<dt><strong><code>alphaArr</code></strong> :&ensp;<code>list[T,P,F]</code></dt>
<dd>Alpha angles for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
per particle.</dd>
<dt><strong><code>betaArr</code></strong> :&ensp;<code>list[T,P,F]</code></dt>
<dd>Beta angles for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
per particle.</dd>
<dt><strong><code>centerArr</code></strong> :&ensp;<code>list[T,P,2]</code></dt>
<dd>List of particle centers (y,x) for T timesteps, with P(T) particles per timestep.</dd>
<dt><strong><code>radiusArr</code></strong> :&ensp;<code>list[T,P]</code></dt>
<dd>List of particle radii for T timesteps, with P(T) particles per timestep.</dd>
<dt><strong><code>angleArr</code></strong> :&ensp;<code>list[T,P]</code></dt>
<dd>List of particle rotations for T timesteps, with P(T) particles per timestep.</dd>
<dt><strong><code>maxBetaDisplacement</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum difference of beta angle between timesteps for which a force will
still be identified with the previous step. The difference is calculated between
the current timestep and whatever the last timestep for which that force existed.</dd>
<dt><strong><code>forcePadValue</code></strong> :&ensp;<code>float</code></dt>
<dd>The value that is recorded for a force that isn't current active for a given frame.
Common choices would be <code>np.nan</code> &ndash; such that the force won't appear when it is
plotted &ndash; or <code>0</code> &ndash; which is a little more physically-inspired.</dd>
<dt><strong><code>continuousBetas</code></strong> :&ensp;<code>bool</code></dt>
<dd>When a force is not active for a number of timesteps, should the beta value (position)
of that force be set to <code>np.nan</code> (<code>False</code>) or should the previous position of the
force be carried over (<code>True</code>)? This is the difference between the force not existing
for these timesteps, versus the force existing but having a magnitude of 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rectForceArr</code></strong> :&ensp;<code>list[P](np.ndarray[F,T])</code></dt>
<dd>A list of arrays representing the force magnitude for each force on each particle.
See description for more info.</dd>
<dt><strong><code>rectAlphaArr</code></strong> :&ensp;<code>list[P](np.ndarray[F,T])</code></dt>
<dd>A list of arrays representing the alpha angle for each force on each particle.
See description for more info.</dd>
<dt><strong><code>rectBetaArr</code></strong> :&ensp;<code>list[P](np.ndarray[F,T])</code></dt>
<dd>A list of arrays representing the beta angle for force on each particle.
See description for more info.</dd>
<dt><strong><code>rectCenterArr</code></strong> :&ensp;<code>np.ndarray[P,T,2]</code></dt>
<dd>Particle centers for each timestep. Elements take on a value of <code>[np.nan, np.nan]</code>
if the particle does not exist for a given timestep.</dd>
<dt><strong><code>rectRadiusArr</code></strong> :&ensp;<code>np.ndarray[P,T]</code></dt>
<dd>Particle radii for each timestep. Elements take on a value of <code>np.nan</code> if the particle
does not exist for a given timestep.</dd>
<dt><strong><code>rectAngleArr</code></strong> :&ensp;<code>np.ndarray[P,T]</code></dt>
<dd>Particle angles for each timestep. Elements take on a value of <code>np.nan</code> if the particle
does not exist for a given timestep.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rectangularizeForceArrays(forceArr, alphaArr, betaArr, centerArr, radiusArr, maxBetaDisplacement=.3, forcePadValue=np.nan, continuousBetas=False):
    &#34;&#34;&#34;
    Take the ragged arrays representing particles and forces and convert them to
    particle-wise rectangular arrays.

    The force input arrays should be 3 dimensional, with indices as follows:

        `forceArr[timestep index]
                [particle index]
                [force index]`

    The center array should be 3 dimensional as well, with indices as follows:

        `centerArr[timestep index]
                 [particle index]
                 [coordination (x or y) index]`

    The radius array should be 2 dimensional:

        `radiusArr[timestep index]
                 [particle index]`

    The final returned result will be a list of rectangular arrays of the form:

        `rectForceArr[particle index]
                    [force index]
                    [timestep index]`

    There are several advantages to restructing like this:

        1.  The evolution of a single force can be plotted with something
            like `plt.plot(rectForceArr[0][0])`. To do this with the input arrays
            would require quite a bit more work since they are lists, and cannot
            be sliced.
        
        2.  While the top-layer index corresponds to a python list, all of the particle-
            wise arrays are numpy objects, which allows them to be sliced/saved easily.

        3.  Due to potentially having different numbers of particles per frame and different
            numbers of forces acting on each particle, the original arrays and very ragged.
            This makes any sane indexing very hard to do, which is fixed by reshaping the
            arrays. If a force only exists for a subset of the time steps, the rectangular
            result will still identify it as a unique force in all timesteps, just with a
            magnitude of 0 (or `np.nan`; see `forcePadValue`).


    Parameters
    ----------

    forceArr : list[T,P,F]
        Force magnitudes for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
        per particle.

    alphaArr : list[T,P,F]
        Alpha angles for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
        per particle.

    betaArr : list[T,P,F]
        Beta angles for T timesteps, with P(T) particles per timestep, and F(P(T)) forces
        per particle.

    centerArr : list[T,P,2]
        List of particle centers (y,x) for T timesteps, with P(T) particles per timestep.

    radiusArr : list[T,P]
        List of particle radii for T timesteps, with P(T) particles per timestep.

    angleArr : list[T,P]
        List of particle rotations for T timesteps, with P(T) particles per timestep.

    maxBetaDisplacement : float
        The maximum difference of beta angle between timesteps for which a force will
        still be identified with the previous step. The difference is calculated between
        the current timestep and whatever the last timestep for which that force existed.

    forcePadValue : float
        The value that is recorded for a force that isn&#39;t current active for a given frame.
        Common choices would be `np.nan` -- such that the force won&#39;t appear when it is
        plotted -- or `0` -- which is a little more physically-inspired.

    continuousBetas : bool
        When a force is not active for a number of timesteps, should the beta value (position)
        of that force be set to `np.nan` (`False`) or should the previous position of the
        force be carried over (`True`)? This is the difference between the force not existing
        for these timesteps, versus the force existing but having a magnitude of 0.

    Returns
    -------

    rectForceArr : list[P](np.ndarray[F,T])
        A list of arrays representing the force magnitude for each force on each particle.
        See description for more info.

    rectAlphaArr : list[P](np.ndarray[F,T])
        A list of arrays representing the alpha angle for each force on each particle.
        See description for more info.

    rectBetaArr : list[P](np.ndarray[F,T])
        A list of arrays representing the beta angle for force on each particle.
        See description for more info.

    rectCenterArr : np.ndarray[P,T,2]
        Particle centers for each timestep. Elements take on a value of `[np.nan, np.nan]`
        if the particle does not exist for a given timestep.

    rectRadiusArr : np.ndarray[P,T]
        Particle radii for each timestep. Elements take on a value of `np.nan` if the particle
        does not exist for a given timestep.

    rectAngleArr : np.ndarray[P,T]
        Particle angles for each timestep. Elements take on a value of `np.nan` if the particle
        does not exist for a given timestep.
    &#34;&#34;&#34;
    rectForceArr = []
    rectBetaArr = []
    rectAlphaArr = []

    # Scalar
    # TODO Make this capable of following same process as for forces, where
    # identities are maintained even if multiple particles appear/disappear
    maxNumParticles = np.max([len(betaArr[i]) for i in range(len(betaArr))])
    numTimesteps = len(forceArr)
    # First, make the centers array look nice, which we then use to identify
    # particles
    rectCenterArr = np.zeros((maxNumParticles, numTimesteps, 2))
    rectRadiusArr = np.zeros((maxNumParticles, numTimesteps))
    #rectAngleArr = np.zeros((maxNumParticles, numTimesteps))

    # We have to initialize the first element so that we can then use the
    # preserveOrderSort function to make sure the identities stay
    # consistent
    rectCenterArr[:,0] = list(centerArr[0]) + [[np.nan, np.nan]]*(maxNumParticles - len(centerArr[0]))
    rectRadiusArr[:,0] = list(radiusArr[0]) + [np.nan]*(maxNumParticles - len(centerArr[0]))
    #rectAngleArr[:,0] = list(angleArr[0]) + [np.nan]*(maxNumParticles - len(centerArr[0]))

    particleOrder = np.zeros((numTimesteps, maxNumParticles), dtype=np.int16)
    particleOrder[0] = np.arange(len(particleOrder[0]))
    particleExists = np.zeros((numTimesteps, maxNumParticles), dtype=np.int16)

    for i in range(1, numTimesteps):
        currOrder = preserveOrderArgsort(rectCenterArr[:,i-1], centerArr[i], padMissingValues=True, fillNanSpots=True)
        # Convert all None to -1 (since None can&#39;t be turned into an integer)
        particleOrder[i] = [ci if ci is not None else -1 for ci in currOrder]
        rectCenterArr[:,i] = [centerArr[i][particleOrder[i,j]] if particleOrder[i,j] &gt;= 0 else [np.nan, np.nan] for j in range(len(particleOrder[i]))]
        rectRadiusArr[:,i] = [radiusArr[i][particleOrder[i,j]] if particleOrder[i,j] &gt;= 0 else np.nan for j in range(len(particleOrder[i]))]
        #rectAngleArr[:,i] = [angleArr[i][particleOrder[i,j]] if particleOrder[i,j] &gt;= 0 else np.nan for j in range(len(particleOrder[i]))]

    # The angles were actually just changes in angle, so we should do a cumulative sum
    # using arange because we want to go backwards
    #for i in np.arange(1, numTimesteps)[::-1]:
    #    rectAngleArr[:,i] = np.sum(rectAngleArr[:,:i], axis=-1)

    # We now have linked the particles from frame to frame, and can
    # rectangularize the other quantities on a particle-by-particle basis
    for i in range(maxNumParticles):
        # Unfortunately, we cannot determine the maximum number of forces just by doing a
        # call to np.max(len(...)) or something, because eg. two frames could have 3 and 4
        # forces in each, but those could represent up to 7 unique forces total

        # This will be triangular array representing the indices of each force in the final
        # rectangular array
        # We have to make sure this particle exists at the first timestep as well
        #print(particleOrder[0])
        #print(betaArr[0])
        if particleOrder[0,i] &gt;= 0 and particleOrder[0,i] &lt; len(betaArr[0]):
            triSortedBetaArr = [betaArr[0][particleOrder[0,i]]]
            triSortedForceOrderArr = [list(np.arange(len(triSortedBetaArr[0])))]
        else:
            # Otherwise, we just use an empty list
            triSortedBetaArr = [[]]
            triSortedForceOrderArr = [[]]


        for j in range(1, numTimesteps):
            particleIndex = particleOrder[j,i]
   
            # If less than 0, that means this particle is not actually present in this
            # frame, so we just continue. Note that we do have to carry forward the
            # beta values from the previous frame, since otherwise we will run into
            # issues later on.
            if particleIndex &lt; 0:
                triSortedBetaArr.append(triSortedBetaArr[-1])
                triSortedForceOrderArr.append([None for i in range(len(triSortedBetaArr[-1]))])
                continue

            # Correlate the particles between this frame and the last
            #print(triSortedBetaArr[-1])
            order = preserveOrderArgsort(triSortedBetaArr[-1], betaArr[j][particleIndex], padMissingValues=True, maxDistance=maxBetaDisplacement, periodic=True)
            # If we &#34;lose&#34; a force, carry the old beta value through to the new array, so
            # that we can identify it if it ever pops up again.
            betaValues = [betaArr[j][particleIndex][order[k]] if order[k] is not None else triSortedBetaArr[-1][k] for k in range(len(order))]
            #print(betaValues)
            triSortedBetaArr.append(betaValues)
            #triSortedForceOrderArr.append([i for i in order if i is not None])
            triSortedForceOrderArr.append(order)

        # Since the triangular array is only allowed to grow, the length of the last
        # entry will be the maximum number of *unique* forces.
        #plt.plot([len(ele) for ele in triSortedBetaArr]) # Check that it only grows
        #plt.show()
        maxNumForces = len(triSortedBetaArr[-1])

        # Now we can finally create some nice rectangular arrays
        singleParticleForceArr = np.zeros((maxNumForces, numTimesteps))
        singleParticleBetaArr = np.zeros((maxNumForces, numTimesteps))
        singleParticleAlphaArr = np.zeros((maxNumForces, numTimesteps))

        for j in range(numTimesteps):
            particleIndex = particleOrder[j,i]

            # If particle doesn&#39;t exist for this frame, fill with nan values and move
            # on
            if particleIndex &lt; 0:
                singleParticleBetaArr[:,j] = np.repeat(np.nan, maxNumForces)
                singleParticleForceArr[:,j] = np.repeat(forcePadValue, maxNumForces)
                singleParticleAlphaArr[:,j] = np.repeat(np.nan, maxNumForces)
                continue

            # We want to remove the carry over beta values for forces that aren&#39;t actually there
            # now, and then pad with nan values for forces that haven&#39;t appeared yet

            # Not sure why, but it may be helpful to have the previous beta values carried over,
            # so that can be done by passing a kwarg
            if continuousBetas:
                singleParticleBetaArr[:,j] = [triSortedBetaArr[j][k] for k in range(len(triSortedBetaArr[j]))] + [np.nan]*(maxNumForces - len(triSortedBetaArr[j]))
            else:
                singleParticleBetaArr[:,j] = [betaArr[j][particleIndex][triSortedForceOrderArr[j][k]] if triSortedForceOrderArr[j][k] is not None else np.nan for k in range(len(triSortedBetaArr[j]))] + [np.nan]*(maxNumForces - len(triSortedBetaArr[j]))

            # I apologize to anyone who has to read these lines... They do exactly what is stated above,
            # but boy do they look terrible
            singleParticleForceArr[:,j] = [forceArr[j][particleIndex][triSortedForceOrderArr[j][k]] if triSortedForceOrderArr[j][k] is not None else forcePadValue for k in range(len(triSortedBetaArr[j]))] + [forcePadValue]*(maxNumForces - len(triSortedBetaArr[j]))
            singleParticleAlphaArr[:,j] = [alphaArr[j][particleIndex][triSortedForceOrderArr[j][k]] if triSortedForceOrderArr[j][k] is not None else np.nan for k in range(len(triSortedBetaArr[j]))] + [np.nan]*(maxNumForces - len(triSortedBetaArr[j]))

        # Append all of the nice rectangular arrays
        rectForceArr.append(singleParticleForceArr)
        rectAlphaArr.append(singleParticleAlphaArr)
        rectBetaArr.append(singleParticleBetaArr)

    return rectForceArr, rectAlphaArr, rectBetaArr, rectCenterArr, rectRadiusArr#, rectAngleArr</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pepe.utils" href="index.html">pepe.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pepe.utils.RectArr.rectangularizeForceArrays" href="#pepe.utils.RectArr.rectangularizeForceArrays">rectangularizeForceArrays</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>