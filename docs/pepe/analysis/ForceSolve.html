<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>pepe.analysis.ForceSolve API documentation</title>
<meta name="description" content="Methods to solve for vector contact forces from a photoelastic image.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pepe.analysis.ForceSolve</code></h1>
</header>
<section id="section-intro">
<p>Methods to solve for vector contact forces from a photoelastic image.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pepe.analysis.ForceSolve.detectWallContacts"><code class="name flex">
<span>def <span class="ident">detectWallContacts</span></span>(<span>centers, radii, boundaryMask, photoelasticSingleChannel=None, contactPadding=10, g2EdgePadding=0.95, contactG2Threshold=0.0001, angleClusterThreshold=0.2, contactMaskRadius=50, extendedContacts=False, maxContactExtent=0.75)</span>
</code></dt>
<dd>
<div class="desc"><p>Detect potential particle contacts with the wall.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>centers</code></strong> :&ensp;<code>np.ndarray[N,2] </code></dt>
<dd>A list of N centers of format [y, x].</dd>
<dt><strong><code>radii</code></strong> :&ensp;<code>np.ndarray[N]</code></dt>
<dd>A list of N radii, corresponding to each particle center</dd>
<dt><strong><code>boundaryMask</code></strong> :&ensp;<code>np.uint8[H,W]</code></dt>
<dd>Mask removing uneccesary parts of the image, that is used
to detect boundaries. Locations with a value of 0 will be assumed to be
solid walls, that a particle could potentially be in contact with.</dd>
<dt><strong><code>photelasticSingleChannel</code></strong> :&ensp;<code>np.uint8[H,W]</code></dt>
<dd>A single channel image in array form of the photoelastic response of particles.
Is used to determine if a contact is actually force bearing or not. If not
provided, all potential contacts will be returned.</dd>
<dt><strong><code>contactPadding</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum difference between distance between a particle's edge and the wall
that will still be tested as a wall contact.</dd>
<dt><strong><code>g2EdgePadding</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Number of pixels to ignore at the edge of each particle when calculating the average
G^2. If float value &lt; 1 is passed, gradient mask radius will be taken as that percent
of the full particle radius. A value of 0 means no padding is included.</dd>
<dt><strong><code>contactG2Threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>The neighbor weight value under which edges will be removed from the network,
as they would be considered to weak to represent anything physical. This will
help remove particle neighbors that are only barely touching, but not transmitting
any real force.</dd>
<dt><strong><code>angleClusterThreshold</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum difference in consecutive angle (beta) for which two wall contacts
will be considered unique (and not merged into the same contact).</dd>
<dt><strong><code>contactMaskRadius</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of the circular mask that is used to determine average gradient squared
value around detected contacts.</dd>
<dt><strong><code>extendedContacts</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to break up larger potential contacts in multiple. See <code>maxContactExtent</code>.</dd>
<dt><strong><code>maxContactExtent</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum range of angles that can be included in a single cluster. If any particular
cluster exceeds this value, it will be divided up into multiple new clusters.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>numWallContacts</code></strong> :&ensp;<code>np.ndarray[N]</code></dt>
<dd>The number of wall contacts for each particle (denoted as Z_i in other return values).</dd>
<dt><strong><code>betaArr</code></strong> :&ensp;<code>np.ndarray[N, Z_i]</code></dt>
<dd>A list of angles for each particle in which there likely is a wall contact.</dd>
<dt><strong><code>contactG2Arr</code></strong> :&ensp;<code>np.ndarray[N, Z_i]</code></dt>
<dd>A list of average gradient squared values for each wall contact, to be
multiplied by the g2 calibration value to get the initial force magnitude guess.</dd>
</dl></div>
</dd>
<dt id="pepe.analysis.ForceSolve.forceOptimize"><code class="name flex">
<span>def <span class="ident">forceOptimize</span></span>(<span>forceGuessArr, betaGuessArr, alphaGuessArr, radius, center, realImage, fSigma, pxPerMeter, brightfield, parametersToFit=['f', 'a'], method='nelder', maxEvals=300, forceBounds=(0, 5), betaBounds=(-3.141592653589793, 3.141592653589793), alphaBounds=(-1.5707963267948966, 1.5707963267948966), forceTolerance=0.5, betaTolerance=0.2, alphaTolerance=0.1, useTolerance=True, returnOptResult=False, allowAddForces=True, allowRemoveForces=True, minForceThreshold=0.01, contactMaskRadius=30, newBetaMinSeparation=0.4, newBetaG2Height=0.0005, missingForceChiSqrThreshold=210000000.0, imageScaleFactor=1, localizeAlphaOptimization=True, forceBalanceWeighting=0.2, debug=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Optimize an initial guess for the forces acting on a particle using
a nonlinear minimization function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>forceGuessArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>The initial guess for magnitudes of each force that is acting on the particle.</dd>
<dt><strong><code>betaGuessArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>The initial guess for the positional angles where each force is acting (in radians).</dd>
<dt><strong><code>alphaGuessArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>The initial guess for the directional angles for each force acting on the particle (in radians).</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the particle, in pixels.</dd>
<dt><strong><code>center</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>The coordinates of the center, [y,x], of the particle.</dd>
<dt><strong><code>realImage</code></strong> :&ensp;<code>np.ndarray[H,W]</code></dt>
<dd>The photoelastic channel that the optimizer will compare against. Can be a composite image
include other particles, since a mask will be applied around the given particle.</dd>
<dt><strong><code>parametersToFit</code></strong> :&ensp;<code>['f'[[, 'b'], 'a']]</code></dt>
<dd>
<p>Which parameters should be allowed to be varied in the process of minimizing the function; 'f' for
force magnitude, 'b' for beta positional angle, 'a' for alpha directional angle. Must include at least one.</p>
<p>Can also specify to perform multiple optimizations on different variables by providing a 2D list of
parameters keys (any of 'f', 'a', 'b') e.g. [ ['f', 'b'], ['f', 'a'] ] will first optimize the force
and beta values, then optimize the force and alpha values. When performing multiple optimizations,
the result of the previous one is used as initial condition for the following one, though the residual
array includes information about all optimizations. </p>
<p>Values for <code>maxEvals</code>, <code>forceTol</code>, <code>betaTol</code>, <code>alphaTol</code>, and <code>method</code> can be provided as lists of
acceptable values to specify different options for each optimization e.g. <code>method=['nelder', 'cobyla']</code>
will use the Nelder-Mead optimization scheme on the first pass, and then COBYLA on the second one. If
a single value is provided for any of these parameters, that will be used for all optimizations.</p>
</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>The method to use for optimization. See wiki page on Force Solver for more information on selecting
an appropriate one. Generally any method from <a href="https://lmfit.github.io/lmfit-py/fitting.html#the-minimize-function">lmfit</a>
can be used, but the following tend to give the best results:</p>
<ul>
<li>
<p><code>lm</code> - Levenberg-Marquardt</p>
</li>
<li>
<p><code>least_squares</code> - Trust region reflective</p>
</li>
<li>
<p><code>nelder</code> - Nelder-Mead</p>
</li>
</ul>
<p>Can be provided as a list of values when performing multiple optimizations; see <code>parametersToFit</code>.</p>
</dd>
<dt><strong><code>maxEvals</code></strong> :&ensp;<code>int</code></dt>
<dd>
<p>The maximum number of function evaluations before the minimizer exits. Convergence can occur before
this number of evaluations, but process will be interrupted at this value regardless of whether
or not the result has converged.</p>
<p>Can be provided as a list of values when performing multiple optimizations; see <code>parametersToFit</code>.</p>
</dd>
<dt><strong><code>forceBounds</code></strong> :&ensp;<code>(float, float)</code></dt>
<dd>The upper and lower limits for the values of force magnitudes that the minimizer can explore,
assuming that <code>useTolerance</code> is set to False.</dd>
<dt><strong><code>betaBounds</code></strong> :&ensp;<code>(float, float)</code></dt>
<dd>The upper and lower limits for the values of beta that the minimizer can explore,
assuming that <code>useTolerance</code> is set to False.</dd>
<dt><strong><code>alphaBounds</code></strong> :&ensp;<code>(float, float)</code></dt>
<dd>The upper and lower limits for the values of alpha that the minimizer can explore,
assuming that <code>useTolerance</code> is set to False.</dd>
<dt><strong><code>forceTolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>If <code>useTolerance</code> is set to True, this value will be used to calculate the bounds for each
force individually, as the initial value minus this tolerance, and the initial value plus
this tolerance.</p>
<p>Can be provided as a list of values when performing multiple optimizations; see <code>parametersToFit</code>.</p>
</dd>
<dt><strong><code>betaTolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>If <code>useTolerance</code> is set to True, this value will be used to calculate the bounds for each
beta individually, as the initial value minus this tolerance, and the initial value plus
this tolerance.</p>
<p>Can be provided as a list of values when performing multiple optimizations; see <code>parametersToFit</code>.</p>
</dd>
<dt><strong><code>alphaTolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>If <code>useTolerance</code> is set to True, this value will be used to calculate the bounds for each
alpha individually, as the initial value minus this tolerance, and the initial value plus
this tolerance.</p>
<p>Can be provided as a list of values when performing multiple optimizations; see <code>parametersToFit</code>.</p>
</dd>
<dt><strong><code>useTolerance</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to calculate the bounds for each parameters as the initial value plus/minus a
certain tolerance (True) or to use the set intervals provided via the <code>forceBounds</code>,
<code>betaBounds</code>, and <code>alphaBounds</code> parameters (False).</dd>
<dt><strong><code>returnOptResult</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to return the optimizer result object, which includes all parameters values and
potentially uncertainties (True) or just the optimized values of the forces, betas, alphas,
and residuals (False). Note that if multiple optimizations are being performed, only the
final result object will be returned.</dd>
<dt><strong><code>allowAddForces</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to allow the optimization routine to attempt to detect missing forces,
and add them in. This detection is done by examining the gradient squared of the
photoelastic image provided to the method (<code>realImage</code>). If a force is added, the
last optimization routine will be run again, with the added ability to vary the
contact position, beta (if this was not already the case).</dd>
<dt><strong><code>allowRemoveForces</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to allow the optimization routine to remove forces that have a
magnitude below a certain threshold (see <code>minForceThreshold</code>).</dd>
<dt><strong><code>minForceThreshold</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimizer will automatically remove any forces whose magnitude is lower than
this value between fittings and after the final one.</dd>
<dt><strong><code>contactMaskRadius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius in pixels of the circular mask applied over contacts, either during localized
alpha optimization (see <code>localizeAlphaOptimization</code>) or detection of missing
contacts (see <code>allowAddForces</code>).</dd>
<dt><strong><code>newBetaMinSeparation</code></strong> :&ensp;<code>float</code></dt>
<dd>The minimum separation for a potential new contact (see <code>allowAddForces</code>) to be
considered as a real force to be added. Larger values can prevent doubling up
on forces, when there is really only a single, extended contact point</dd>
<dt><strong><code>newBetaG2Height</code></strong> :&ensp;<code>float</code></dt>
<dd>The threshold for average gradient squared value in a localized region around
a potential new contact.</dd>
<dt><strong><code>missingForceChiSqrThreshold</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>The minimum chi squared value (as calculated by the optimization routine; analagous to error)
above which the method will attempt to detect missing forces.</p>
<p>Found by experimentation.</p>
</dd>
<dt><strong><code>localizeAlphaOptimization</code></strong> :&ensp;<code>bool</code></dt>
<dd>When optimizing for the incident angle (alpha) alone, the effect of varying
this value can be very subtle across the entire particle. This parameter will have
the largest effect in a small region around the contact. If this value is <code>True</code>,
optimizations only for alpha (done by passing <code>parametersToFit=['a']</code>, or similar)
will mask the particle except for a small region around the contact.</dd>
<dt><strong><code>imageScaleFactor</code></strong> :&ensp;<code>int &gt; 1</code> or <code>positive float &lt; 1</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>Factor by which to scale the real image when optimizating. Integer larger than 1 will
lead to the image being upsampled, and float less than 1 (but greater than 0) will lead
to the image being downsampled.</p>
<p>Must lead to an integer up- or downscale factor; for upscaling this is not an issue, but
downscale factors may be rounded in not the exact inverse of an integer. eg. a value of <code>.35</code>
will result in a downscale by a factor of 3, not 2.85.</p>
<dl>
<dt><strong><code>forceBalanceWeighting</code></strong> :&ensp;<code>float</code></dt>
<dd>If set to some non-zero and non-None value, the optimization cost will include a
contribution depending on how badly the ensemble of forces satisfy force balance.</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether or not to print out status statements as the optimization is performed.</dd>
</dl></div>
</dd>
<dt id="pepe.analysis.ForceSolve.g2ForceCalibration"><code class="name flex">
<span>def <span class="ident">g2ForceCalibration</span></span>(<span>fSigma, radius, pxPerMeter=1.0, g2Padding=1, alphaArr=array([0., 0.]), betaArr=array([ 0.
, -3.14159265]), forceSteps=100, forceBounds=array([0.01, 1.
]), brightfield=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Use synthetic photoelastic response to fit the conversion constant between
gradient squared value and force (in Newtons), assuming a linear relationship.</p>
<p>Note that this computes the least squares of force (N) vs <strong>average</strong> gradient
squared. The Matlab just uses the sum of gradient squared, but this is not invariant
under changes of resolution, so I have opted to use the average. Because of this, a
calibration value calculated in Matlab will <strong>not</strong> work here unless you divide out
the number of points it is summed over first.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fSigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Stress optic coefficient, relating to material thickness, wavelength of light
and other material property (C).</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the particle that is being simulated in pixels. If pxPerMeter is
not provided (or set to 1), this value will be assumed to already have been converted to meters.</dd>
<dt><strong><code>contactMaskRadius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the circular mask that is applied over each contact to find the average gradient
squared.</dd>
<dt><strong><code>pxPerMeter</code></strong> :&ensp;<code>float</code></dt>
<dd>The number of pixels per meter for the simulated image. If not provided, or set to 1, the radius
value will be assumed to already have been converted to meters.</dd>
<dt><strong><code>g2Padding</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of pixels to ignore at the edge of the particle. We don't expect any boundary
artifacts in our synthetic data, but we will eventually do this for the real data,
so it is important to keep the size of the particles the same throughout.</dd>
<dt><strong><code>alphaArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of angles representing force contact angles.</dd>
<dt><strong><code>betaArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of angles representing force contact positions.</dd>
<dt><strong><code>forceSteps</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of points to use for fitting our line of g^2 vs. force.</dd>
<dt><strong><code>forceBounds</code></strong> :&ensp;<code>[float, float]</code></dt>
<dd>The minimum and maximum value of force applied to calculate the calibration value.</dd>
<dt><strong><code>brightfield</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the intensity should be simulated as seen through a brightfield (True)
polariscope or darkfield (False) polariscope.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>g2ForceSlope</code></strong> :&ensp;<code>float</code></dt>
<dd>Slope found via linear regression to convert average g^2 to force.</dd>
</dl></div>
</dd>
<dt id="pepe.analysis.ForceSolve.g2ForceCalibrationDebug"><code class="name flex">
<span>def <span class="ident">g2ForceCalibrationDebug</span></span>(<span>fSigma, radius, pxPerMeter, alphaArr=array([0., 0.]), betaArr=array([ 0.
, -3.14159265]), forceSteps=100, forceBounds=array([0.01, 1.
]), brightfield=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Use synthetic photoelastic response to fit the conversion constant between
gradient squared value and force (in Newtons), assuming a linear relationship.</p>
<p>Returns the X and Y values that a line would be fit to, instead of the
fit paramters themselves. See pepe.analysis.g2ForceCalibration().</p>
<p>Note that this computes the least squares of force (N) vs <strong>average</strong> gradient
squared. The Matlab just uses the sum of gradient squared, but this is not invariant
under changes of resolution, so I have opted to use the average. Because of this, a
calibration value calculated in Matlab will <strong>not</strong> work here unless you divide out
the number of points it is summed over first.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fSigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Stress optic coefficient, relating to material thickness, wavelength of light
and other material property (C).</dd>
<dt><strong><code>radius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the particle that is being simulated in pixels. If pxPerMeter is
not provided (or set to 1), this value will be assumed to already have been converted to meters.</dd>
<dt><strong><code>contactMaskRadius</code></strong> :&ensp;<code>float</code></dt>
<dd>Radius of the circular mask that is applied over each contact to find the average gradient
squared.</dd>
<dt><strong><code>pxPerMeter</code></strong> :&ensp;<code>float</code></dt>
<dd>The number of pixels per meter for the simulated image. If not provided, or set to 1, the radius
value will be assumed to already have been converted to meters.</dd>
<dt><strong><code>alphaArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of angles representing force contact angles.</dd>
<dt><strong><code>betaArr</code></strong> :&ensp;<code>np.ndarray[Z]</code></dt>
<dd>Array of angles representing force contact positions.</dd>
<dt><strong><code>forceSteps</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of points to use for fitting our line of g^2 vs. force.</dd>
<dt><strong><code>forceBounds</code></strong> :&ensp;<code>[float, float]</code></dt>
<dd>The minimum and maximum value of force applied to calculate the calibration value.</dd>
<dt><strong><code>brightfield</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the intensity should be simulated as seen through a brightfield (True)
polariscope or darkfield (False) polariscope.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>forceArr</code></strong> :&ensp;<code>np.ndarray[forceSteps]</code></dt>
<dd>Force applied (in Newtons) at each point</dd>
<dt><strong><code>g2AvgArr</code></strong> :&ensp;<code>np.ndarray[forceSteps]</code></dt>
<dd>Resultant average gradient squared across the particle at each point.</dd>
</dl></div>
</dd>
<dt id="pepe.analysis.ForceSolve.initialForceSolve"><code class="name flex">
<span>def <span class="ident">initialForceSolve</span></span>(<span>photoelasticSingleChannel, centers, radii, fSigma, pxPerMeter, contactPadding=10, g2EdgePadding=1, contactG2Threshold=0.1, contactMaskRadius=40, neighborEvaluations=4, boundaryMask=None, ignoreBoundary=True, brightfield=False, boundaryDetectionOptions={}, g2Cal=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the approximate forces on each particle based on the photoelastic response.
No optimization/gradient descent is done in this method; this should be used either where
rough estimates of the forces are fine, or as an initial condition for a fitting function.</p>
<p>Heavily based on James Puckett's PhD thesis (2012) and Jonathan Kollmer's PeGS:
<a href="https://github.com/jekollmer/PEGS">https://github.com/jekollmer/PEGS</a></p>
<p>Daniels, K. E., Kollmer, J. E., &amp; Puckett, J. G. (2017). Photoelastic force
measurements in granular materials. Review of Scientific Instruments, 88(5),
051808. <a href="https://doi.org/10.1063/1.4983049">https://doi.org/10.1063/1.4983049</a></p>
<p>Outline of the process:</p>
<ol>
<li>Track particles to get centers and radii (external)</li>
<li>Calculate average gradient squared for each particle</li>
<li>Find which particles are in contact with each other</li>
<li>Determine if there are any boundary contacts (optional)</li>
<li>Calculate the position of each (boundary or interparticle) force for each particle</li>
<li>Use the average gradient from step 1 to estimate the magnitude of force at each position</li>
</ol>
<p>Intended to be used as the initial condition for optimization process; see
<code>pepe.analysis.forceOptimize()</code> for more information.</p>
<p>When significant noise is present in the images, this method will often way overestimate
the magnitudes of forces (because it is based on the gradient squared). If the guesses
are much too high, it can be better to just set all force magnitudes to a reasonable
flat value, like <code>.1</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>photelasticSingleChannel</code></strong> :&ensp;<code>np.uint8[H,W]</code></dt>
<dd>A single channel image in array form of the photoelastic response of particles.</dd>
<dt><strong><code>centers</code></strong> :&ensp;<code>np.ndarray[N,2] </code></dt>
<dd>A list of N centers of format [y, x].</dd>
<dt><strong><code>radii</code></strong> :&ensp;<code>np.ndarray[N]</code></dt>
<dd>A list of N radii, corresponding to each particle center</dd>
<dt><strong><code>contactPadding</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum difference between distance and sum of radii for which
two particles will still be considered in contact.</dd>
<dt><strong><code>g2EdgePadding</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Number of pixels to ignore at the edge of each particle when calculating the average
G^2. If float value &lt; 1 is passed, gradient mask radius will be taken as that percent
of the full particle radius. A value of 0 means no padding is included.</dd>
<dt><strong><code>contactG2Threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>The neighbor weight value under which edges will be removed from the network,
as they would be considered to weak to represent anything physical. This will
help remove particle neighbors that are only barely touching, but not transmitting
any real force.</dd>
<dt><strong><code>contactMaskRadius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the circular mask applied over a contact to estimate the magnitude
of the force there. Should be smaller than the radius, usually 25% of the radius is fine.
For higher forces, larger mask may be needed.</dd>
<dt><strong><code>neightborEvaluations</code></strong> :&ensp;<code>int</code></dt>
<dd>How many of the closest points to find via the kd tree and test
as potential contacts. For homogeneous circles, or approximately
homogenous (&lt; 2:1 size ratio), 4 should be plenty.</dd>
<dt><strong><code>boundaryMask</code></strong> :&ensp;<code>np.uint8[H,W]</code></dt>
<dd>Optional mask removing uneccesary parts of the image, that is used
to detect boundaries. Locations with a value of 0 will be assumed to be
solid walls, that a particle could potentially be in contact with. If
not provided, or set to None, system will be assumed to be in a rectangular
box defined the most extreme top/bottom/left/right particles.</dd>
<dt><strong><code>ignoreBoundary</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to not attempt to find any contacts with the boundary. This will take effect
regardless of whether a boundary mask is passed as a parameter.</dd>
<dt><strong><code>brightfield</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the photoelastic response is seen through a brightfield (True)
polariscope or darkfield (False) polariscope.</dd>
<dt><strong><code>boundaryDetectionOptions</code></strong> :&ensp;<code>kwargs</code></dt>
<dd>Dictionary of kwargs to be passed to the detectWallContact method, assuming
boundaries are being included in the solver. If none are provided, relevant
values are carried over from the kwargs for this method (<code>contactPadding</code>,
<code>g2EdgePadding</code>, <code>contactMaskRadius</code>, <code>contactG2Threshold</code>).</dd>
<dt><strong><code>g2Cal</code></strong> :&ensp;<code>float</code></dt>
<dd>Gradient squared to force calibration value. For numerous calls of the
function, it is recommended to calculate this value once externally,
and pass it in. If left as None, will be recalculated internally.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>forceGuessArr</code></strong> :&ensp;<code>np.object[N,F(N)]</code></dt>
<dd>Triangular array of force magnitude guesses for N particles with F(N) forces each
(could be different number of forces per particle).</dd>
<dt><strong><code>alphaGuessArr</code></strong> :&ensp;<code>np.object[N,F(N)]</code></dt>
<dd>Triangular array of alpha angle guesses for N particles with F(N) forces each
(could be different number of forces per particle).</dd>
<dt><strong><code>betaGuessArr</code></strong> :&ensp;<code>np.object[N,F(N)]</code></dt>
<dd>Triangular array of beta angle guesses for N particles with F(N) forces each
(could be different number of forces per particle).</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pepe.analysis" href="index.html">pepe.analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pepe.analysis.ForceSolve.detectWallContacts" href="#pepe.analysis.ForceSolve.detectWallContacts">detectWallContacts</a></code></li>
<li><code><a title="pepe.analysis.ForceSolve.forceOptimize" href="#pepe.analysis.ForceSolve.forceOptimize">forceOptimize</a></code></li>
<li><code><a title="pepe.analysis.ForceSolve.g2ForceCalibration" href="#pepe.analysis.ForceSolve.g2ForceCalibration">g2ForceCalibration</a></code></li>
<li><code><a title="pepe.analysis.ForceSolve.g2ForceCalibrationDebug" href="#pepe.analysis.ForceSolve.g2ForceCalibrationDebug">g2ForceCalibrationDebug</a></code></li>
<li><code><a title="pepe.analysis.ForceSolve.initialForceSolve" href="#pepe.analysis.ForceSolve.initialForceSolve">initialForceSolve</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
