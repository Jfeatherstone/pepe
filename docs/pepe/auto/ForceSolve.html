<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>pepe.auto.ForceSolve API documentation</title>
<meta name="description" content="Start from a directory of images and solve for all of the particle positions, orientations, and forces.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pepe.auto.ForceSolve</code></h1>
</header>
<section id="section-intro">
<p>Start from a directory of images and solve for all of the particle positions, orientations, and forces.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pepe.auto.ForceSolve.forceSolve"><code class="name flex">
<span>def <span class="ident">forceSolve</span></span>(<span>imageDirectory, guessRadius=0.0, fSigma=0.0, pxPerMeter=0.0, brightfield=True, contactPadding=15, g2MaskPadding=2, contactMaskRadius=30, lightCorrectionImage=None, lightCorrectionHorizontalMask=None, lightCorrectionVerticalMask=None, g2CalibrationImage=None, g2CalibrationCutoffFactor=0.9, maskImage=None, cropXMin=None, cropXMax=None, peBlurKernel=3, imageExtension='bmp', requireForceBalance=False, imageStartIndex=None, imageEndIndex=None, carryOverAlpha=True, carryOverForce=True, circleDetectionMethod='convolution', circleTrackingKwargs={}, circleTrackingChannel=0, circleTrackingGain=1.0, maxBetaDisplacement=0.5, photoelasticChannel=1, photoelasticGain=1.0, forceNoiseWidth=0.03, alphaNoiseWidth=0.01, optimizationKwargs={}, performOptimization=True, debug=False, showProgressBar=True, progressBarOffset=0, progressBarTitle=None, saveMovie=False, outputRootFolder='./', inputSettingsFile=None, pickleArrays=True, genFitReport=True, outputExtension='')</span>
</code></dt>
<dd>
<div class="desc"><p>Complete pipeline to solve for forces and particle positions for all image files
in a directory. Results will be returned and potentially written to various files.
See <code>Returns</code> section for more information</p>
<p>Expects all particles to be the same (or very similar) sizes. This assumption is made
by the calculation of the gradient squared calibration value, which is computed just
once using the guess of the radii. This should not be a problem if the radii are only
slightly varied (~10 pixels or something) but any more than that and errors will begin
to accumulate.</p>
<p>This method has <strong>a lot</strong> of arguments; it is intended to be used once reasonable
values for all of these have already been found. While the <code>debug</code> option for this function
is very helpful, it is recommended to utilize the various notebooks/examples to find good
choices for parameters first.</p>
<p>The output readme file can also serve as a cache of the parameter values/settings, which
can be passed back to future calls of this method using the <code>inputSettingsFile</code> argument.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>imageDirectory</code></strong> :&ensp;<code>str</code></dt>
<dd>An absolute or relative path to the directory containing the images that are
to be analyzed. The names of the images need not follow any particular naming
scheme, but they should be such that sorting the list alphabetically will give
the images in their proper order.</dd>
<dt><strong><code>guessRadius</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>The radius of the particles to be detected, in pixels. As of now, this value will
be taken as the particle radius, but future versions may be able to vary this to
find the optimal value.</p>
<p>Currently no support for particles of different sizes.</p>
</dd>
<dt><strong><code>fSigma</code></strong> :&ensp;<code>float</code></dt>
<dd>Stress optic coefficient, relating to material thickness, wavelength of light and
other material property (denoted as C in most literature; sometimes also called the
"stress optic coefficient").</dd>
<dt><strong><code>pxPerMeter</code></strong> :&ensp;<code>float</code></dt>
<dd>
<p>The number of pixels per meter in the images. Depends on the camera, lens, and
zoom settings used to capture the images.</p>
<p>Note that this is <strong>not</strong> the inverse of the number of pixels per meter, as is used
in some of the other force solving implementations.</p>
</dd>
<dt><strong><code>brightfield</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the images are captured using a brightfield polariscope (<code>True</code>) or
a darkfield polariscope (<code>False</code>).</dd>
<dt><strong><code>contactPadding</code></strong> :&ensp;<code>int</code></dt>
<dd>Maximum distance (in pixels) between a particle's edge and the wall or the edges of two
particles that will still be considered a potential force-bearing contact.</dd>
<dt><strong><code>g2MaskPadding</code></strong> :&ensp;<code>int</code> or <code>float</code></dt>
<dd>Number of pixels to ignore at the edge of each particle when calculating the average G^2.
If float value &lt; 1 is passed, gradient mask radius will be taken as that percent of the full
particle radius. A value of 0 means no padding is included.</dd>
<dt><strong><code>contactMaskRadius</code></strong> :&ensp;<code>float</code></dt>
<dd>The radius of the circular mask that will be constructed around each contact to estimate
the magnitude of the force using the gradient squared in that region.</dd>
<dt><strong><code>lightCorrectionImage</code></strong> :&ensp;<code>str</code> or <code>np.ndarray[H,W[,C]]</code></dt>
<dd>The path to an image (or an array representing an image) that contains no particles, and
can be used to correct for any light gradients present in the actual data.</dd>
<dt><strong><code>lightCorrectionHorizontalMask</code></strong> :&ensp;<code>str</code> or <code>np.ndarray[H,W[,C]]</code></dt>
<dd>A mask array, containing values of <code>0</code> or <code>1</code>, with the latter representing areas over which
the horizontal light correction should be calculated. Can also be a path to an image.</dd>
<dt><strong><code>lightCorrectionVerticalMask</code></strong> :&ensp;<code>str</code> or <code>np.ndarray[H,W[,C]]</code></dt>
<dd>A mask array, containing values of <code>0</code> or <code>1</code>, with the latter representing areas over which
the vertical light correction should be calculated. Can also be a path to an image.</dd>
<dt><strong><code>g2CalibrationImage</code></strong> :&ensp;<code>str</code> or <code>np.ndarray[H,W,C]</code></dt>
<dd>An image with a single particle (or at least one particle) that has no force acting on it.
Used to determine the base level of gradient squared (due to noise) for a free particle. Can
also be a path to an image.</dd>
<dt><strong><code>g2CalibrationCutoffFactor</code></strong> :&ensp;<code>float</code></dt>
<dd>The factor that is multipled by the mean gradient squared value of the particles in the
calibration image. Any particle that has an average gradient squared value below the
calibration value multipled by this factor will be assumed to have no forces acting on it.</dd>
<dt><strong><code>maskImage</code></strong> :&ensp;<code>str</code> or <code>np.ndarray[H,W,C]</code></dt>
<dd>A mask array, containing values of <code>0</code> or <code>1</code>, with the latter representing the regions of
importance for the image. Used in detecting particles, generating initial guesses, and
calculating error during non-linear optimization. can also be a path to an image.</dd>
<dt><strong><code>cropXMin</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Left bound to crop down the image in the x direction.</dd>
<dt><strong><code>cropXMax</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Right bound to crop down the image in the x direction.</dd>
<dt><strong><code>peBlurKernel</code></strong> :&ensp;<code>int</code></dt>
<dd>The kernel size that will be used for bluring the photoelastic channel of each image, to
reduce noise. Should be an odd integer.</dd>
<dt><strong><code>imageExtension</code></strong> :&ensp;<code>str</code></dt>
<dd>The extension of the image files that will be read in from <code>imageDirectory</code>. Should not include
the '.' before the extension.</dd>
<dt><strong><code>requireForceBalance</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to impose particle-wise force balance at each step (<code>True</code>) or to take the results of
the optimization process as they are (<code>False</code>).</p>
<p>Currently WIP, and does not do anything.</p>
</dd>
<dt><strong><code>forceBalanceWeighting</code></strong> :&ensp;<code>float</code></dt>
<dd>If a non-zero positive value, adds a contribution to the optimization cost
pertaining to how well the ensemble of forces satisfy force balance.</dd>
<dt><strong><code>imageStartIndex</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>The index of which image to start at when analyzing the files in <code>imageDirectory</code>. Value
of <code>None</code> will start at the first (alphabetically sorted) image.</dd>
<dt><strong><code>imageEndIndex</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>The index of which image to end at when analyzing the files in <code>imageDirectory</code>. Value
of <code>None</code> will end at the last (alphabetically sorted) image.</dd>
<dt><strong><code>circleDetectionMethod</code></strong> :&ensp;<code>['convolution'</code> or <code>'hough']</code></dt>
<dd>
<p>Whether to use the convolution or hough circle detection method to identify particles.</p>
<p>See <code>pepe.tracking.convCircle()</code> and <code>pepe.tracking.houghCircle()</code> for more information.</p>
</dd>
<dt><strong><code>circleTrackingKwargs</code></strong> :&ensp;<code>**kwargs</code></dt>
<dd>
<p>Keyword arguments to be passed to the selected circle tracking function.</p>
<p>See <code>pepe.tracking.convCircle()</code> and <code>pepe.tracking.houghCircle()</code> for more information.</p>
</dd>
<dt><strong><code>circleTrackingChannel</code></strong> :&ensp;<code>int</code></dt>
<dd>The channel of the image that will be used to track the particles. <code>0</code> for red, <code>1</code> for
green, and <code>2</code> for blue.</dd>
<dt><strong><code>circleTrackingGain</code></strong> :&ensp;<code>float</code></dt>
<dd>The gain applied to the intensity in the circle tracking channel.</dd>
<dt><strong><code>maxBetaDisplacement</code></strong> :&ensp;<code>float</code></dt>
<dd>The maximum distance (angle) that a force can move between frames and still be identified
as the same force. If a force moves more than this value, it will still be recorded as a force,
but will be considered a new and independent force from any of the ones in the previous frame.</dd>
<dt><strong><code>photoelasticChannel</code></strong> :&ensp;<code>int</code></dt>
<dd>The channel of the image that will be used to gauge the photoelastic response. <code>0</code> for red, <code>1</code> for
green, and <code>2</code> for blue.</dd>
<dt><strong><code>photoelasticGain</code></strong> :&ensp;<code>float</code></dt>
<dd>The gain applied to the intensity in the photoelastic channel.</dd>
<dt><strong><code>forceNoiseWidth</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>The width of the gaussian distribution (centered at 0) that noise is sampled from to add to the
force guesses (potentially from the previous frame). This is done to avoid getting stuck in a local
minimum for too long (adds some Monte-Carlo-esque behavior to the solving).</dd>
<dt><strong><code>alphaNoiseWidth</code></strong> :&ensp;<code>float</code> or <code>None</code></dt>
<dd>The width of the gaussian distribution (centered at 0) that noise is sampled from to add to the
alpha guesses (potentially from the previous frame). This is done to avoid getting stuck in a local
minimum for too long (adds some Monte-Carlo-esque behavior to the solving).</dd>
<dt><strong><code>optimizationKwargs</code></strong> :&ensp;<code>**kwargs</code></dt>
<dd>
<p>Keyword arguments to be passed to the optimization process.</p>
<p>For more information, see <code>pepe.analysis.forceOptimize()</code>.</p>
</dd>
<dt><strong><code>performOptimization</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether or not to perform optimization on the particles.</p>
<p>Mostly included as a debug option, but any real data analysis should
utilize the optimization, as the initial guessing is often not nearly
accurate enough to get any real results.</p>
</dd>
<dt><strong><code>debug</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to print progress updates for each frame to the screen (<code>True</code>) or not (<code>False</code>).</dd>
<dt><strong><code>showProgressBar</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show a progress bar throughout the analysis (<code>True</code>) or not (<code>False</code>). Uses
<code>tqdm</code> library.</dd>
<dt><strong><code>progressBarOffset</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of lines to offset the progress bar by. Generally an internal variable
used when multiple threads are active.</dd>
<dt><strong><code>progressBarTitle</code></strong> :&ensp;<code>str</code></dt>
<dd>The text to be written to the left of the progress bar. Generally an internal variable
controlled by some solving script.</dd>
<dt><strong><code>saveMovie</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to save a compiled gif of the reconstructed forces at each frame at the end (<code>True</code>)
or not (<code>False</code>).</dd>
<dt><strong><code>outputRootFolder</code></strong> :&ensp;<code>str</code></dt>
<dd>The location where the output folder (potentially containg the movie, pickle files, readme, etc.)
will be created. Output folder itself will be named after the <code>imageDirectory</code>, with '_Synthetic'
appended to the end.</dd>
<dt><strong><code>pickleArrays</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to save the forces, betas, alphas, centers, and radii as pickle files (<code>True</code>) or not (<code>False</code>).
Files will be located in the output folder (see <code>outputRootFolder</code>).</dd>
<dt><strong><code>inputSettingsFile</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Path to a readme file containg parameters for the solving process, likely generated from
a previous iteration of the program. Explicitly passed arguments will override those that
are included in the settings file.</p>
<p>Currently WIP and does not do anything.</p>
</dd>
<dt><strong><code>genFitReport</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether or not to generate a fit report of the results, including errors per frame,
examinations of all particles/forces, and settings, compiled in a latex pdf.</p>
<p>Will generate both the compiled file 'FitReport.pdf' and the source directory
'FitReport_src/'.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rectForceArr</code></strong> :&ensp;<code>list[P](np.ndarray[F,T])</code></dt>
<dd>A list of arrays representing the force magnitude for each force on each particle.</dd>
<dt><strong><code>rectAlphaArr</code></strong> :&ensp;<code>list[P](np.ndarray[F,T])</code></dt>
<dd>A list of arrays representing the alpha angle for each force on each particle.</dd>
<dt><strong><code>rectBetaArr</code></strong> :&ensp;<code>list[P](np.ndarray[F,T])</code></dt>
<dd>A list of arrays representing the beta angle for force on each particle.</dd>
<dt><strong><code>rectCenterArr</code></strong> :&ensp;<code>np.ndarray[P,T,2]</code></dt>
<dd>Particle centers for each timestep. Elements take on a value of <code>[np.nan, np.nan]</code>
if the particle does not exist for a given timestep.</dd>
<dt><strong><code>rectRadiusArr</code></strong> :&ensp;<code>np.ndarray[P,T]</code></dt>
<dd>Particle radii for each timestep. Elements take on a value of <code>np.nan</code> if the particle
does not exist for a given timestep.</dd>
<dt><code>Depending on kwarg values, several files may be written created in the output</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>folder, which will be located in <code>outputRootFolder</code> and named according
to:
'&lt;<code>imageDirectory</code>&gt;_Synthetic/'.</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pepe.auto" href="index.html">pepe.auto</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pepe.auto.ForceSolve.forceSolve" href="#pepe.auto.ForceSolve.forceSolve">forceSolve</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
